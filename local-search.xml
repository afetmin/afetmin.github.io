<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于中间件</title>
    <link href="/2021/09/19/%E5%85%B3%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2021/09/19/%E5%85%B3%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>使用 node 构建 web 应用时，并不单单响应一个简单的 hello world，在一个实际的业务中，我们也许会做这些：</p><ul><li>请求方法的判断。</li><li>URL 的路径解析。</li><li>URL 中查询字符串解析。</li><li>Cookie 的解析。</li><li>Basic 认证。</li><li>表单数据的解析。</li><li>任意格式文件的上传处理。</li></ul><p>这样一个完整的项目中需要处理很多的细节，当然你也可以都写在一起，但这样代码的耦合程度太高了，而且以后维护起来也令人头大。</p><p>为此引入<strong>中间件（middleware）</strong>来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。</p><p>理解中间件的最简单的方式是实现一个基础的中间件模式，一个中间件其实就是一个函数。</p><p>一个简单的中间件模式需要一个 use 方法来进行中间件的注册，需要一个 run 来执行这些注册的中间件</p><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = &#123;  fns: [],  callback(ctx) &#123;    <span class="hljs-built_in">console</span>.log(ctx)  &#125;,  use(fn) &#123;    <span class="hljs-keyword">this</span>.fns.push(fn)  &#125;,  run(ctx) &#123;    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>    <span class="hljs-keyword">const</span> next = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      index++    &#125;    <span class="hljs-keyword">this</span>.fns.forEach(<span class="hljs-function">(<span class="hljs-params">fn, idx</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (index === idx) fn(ctx, next)    &#125;)    index === <span class="hljs-keyword">this</span>.fns.length &amp;&amp; <span class="hljs-keyword">this</span>.callback(ctx)  &#125;,&#125;</code></pre></div><p>使用一下：</p><div class="hljs"><pre><code class="hljs jsx">app.use(<span class="hljs-function">(<span class="hljs-params">ctx, next</span>) =&gt;</span> &#123;  ctx.name = <span class="hljs-string">"ranxiu"</span>  next()&#125;)app.use(<span class="hljs-function">(<span class="hljs-params">ctx, next</span>) =&gt;</span> &#123;  ctx.gender = <span class="hljs-string">"girl"</span>  next()&#125;)app.run(&#123;&#125;)<span class="hljs-comment">// 打印：&#123;name:"ranxiu",gender:"girl"&#125;</span></code></pre></div><p>关于 run 函数还有更加优雅的写法：</p><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">ctx, stack</span>) </span>&#123;  <span class="hljs-keyword">const</span> next = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> middleware = stack.shift()    <span class="hljs-keyword">if</span> (middleware) &#123;      middleware(ctx, next) <span class="hljs-comment">// 递归调用</span>    &#125;  &#125;  next()&#125;</code></pre></div><p>再来看看 koa-compose 的中间件：</p><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">middleware</span>) </span>&#123;  <span class="hljs-comment">// 提前判断中间件类型,防止后续错误</span>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(middleware))    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Middleware stack must be an array!"</span>)  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middleware) &#123;    <span class="hljs-comment">// 中间件必须为函数类型</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">"function"</span>)      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Middleware must be composed of functions!"</span>)  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) </span>&#123;    <span class="hljs-comment">// 采用闭包将索引缓存,来实现调用计数</span>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">-1</span>    <span class="hljs-keyword">return</span> dispatch(<span class="hljs-number">0</span>)    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params">i</span>) </span>&#123;      <span class="hljs-comment">// 防止next()方法重复调用</span>      <span class="hljs-keyword">if</span> (i &lt;= index)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"next() called multiple times"</span>))      index = i      <span class="hljs-keyword">let</span> fn = middleware[i]      <span class="hljs-keyword">if</span> (i === middleware.length) fn = next      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 包装next()返回值为Promise对象</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)))      &#125; <span class="hljs-keyword">catch</span> (err) &#123;        <span class="hljs-comment">// 异常处理</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)      &#125;    &#125;  &#125;&#125;</code></pre></div><p>两个字：优雅。有时不得不感慨人和人的差距有时比人和狗的差距还大。</p><p>拿这个 🌰 来说：</p><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">ms</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> setTimeout(resolve, ms || <span class="hljs-number">1</span>))&#125;<span class="hljs-keyword">const</span> arr = []<span class="hljs-keyword">const</span> stack = []<span class="hljs-comment">// type Middleware&lt;T&gt; = (context: T, next: Koa.Next) =&gt; any;</span>stack.push(<span class="hljs-keyword">async</span> (context, next) =&gt; &#123;  arr.push(<span class="hljs-number">1</span>)  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1</span>)  <span class="hljs-keyword">await</span> next()  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1</span>)  arr.push(<span class="hljs-number">6</span>)&#125;)stack.push(<span class="hljs-keyword">async</span> (context, next) =&gt; &#123;  arr.push(<span class="hljs-number">2</span>)  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1</span>)  <span class="hljs-keyword">await</span> next()  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1</span>)  arr.push(<span class="hljs-number">5</span>)&#125;)stack.push(<span class="hljs-keyword">async</span> (context, next) =&gt; &#123;  arr.push(<span class="hljs-number">3</span>)  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1</span>)  <span class="hljs-keyword">await</span> next()  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1</span>)  arr.push(<span class="hljs-number">4</span>)&#125;)<span class="hljs-keyword">await</span> compose(stack)(&#123;&#125;)<span class="hljs-comment">// arr = [1,2,3,4,5,6]</span></code></pre></div><p>当 i 为 3 时，</p><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> fn = middleware[i] <span class="hljs-comment">//fn=undefined</span><span class="hljs-keyword">if</span> (i === middleware.length) fn = next<span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve() <span class="hljs-comment">//!fn为true</span></code></pre></div><p>直接返回 resolve，之后就执行 next()后面的函数</p><div class="hljs"><pre><code class="hljs jsx">stack.push(<span class="hljs-keyword">async</span> (context, next) =&gt; &#123;  arr.push(<span class="hljs-number">3</span>)  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1</span>)  <span class="hljs-keyword">await</span> next()  <span class="hljs-keyword">await</span> wait(<span class="hljs-number">1</span>)  arr.push(<span class="hljs-number">4</span>)&#125;)</code></pre></div><p>执行完后返回第二个 next() 后面继续往下执行，知道所有的中间件执行完毕。</p><p>这便是众人皆知的“洋葱模型”。你也可以选择只添加前置的处理，就是 await next()前面的操作</p><p>，或者后面的处理。@洋葱利用洋葱模型实现了设计圈的前置逻辑的初始化，洋葱 🐂🍺。</p><p>每个中间件足够的小而美，职责单一，同时多个中间件又具备良好的逻辑拓展性和可组合性，并且易于测试。这个设计模式真是太“漂亮”了。</p>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React的diff</title>
    <link href="/2021/09/18/React%E7%9A%84diff/"/>
    <url>/2021/09/18/React%E7%9A%84diff/</url>
    
    <content type="html"><![CDATA[<h1 id="React-的-diff"><a href="#React-的-diff" class="headerlink" title="React 的 diff"></a>React 的 diff</h1><p>一个<code>DOM节点</code>在某一时刻最多会有 4 个节点和它相关。</p><ol><li><code>current Fiber</code>。如果该<code>DOM节点</code>已在页面中，<code>current Fiber</code>代表该<code>DOM节点</code>对应的<code>Fiber节点</code>。</li><li><code>workInProgress Fiber</code>。如果该<code>DOM节点</code>将在本次更新中渲染到页面中，<code>workInProgress Fiber</code>代表该<code>DOM节点</code>对应的<code>Fiber节点</code>。</li><li><code>DOM节点</code>本身。</li><li><code>JSX对象</code>。即<code>ClassComponent</code>的<code>render</code>方法的返回结果，或<code>FunctionComponent</code>的调用结果。<code>JSX对象</code>中包含描述<code>DOM节点</code>的信息。</li></ol><p><code>Diff算法</code>的本质是对比 1 和 4，生成 2</p><h2 id="diff-算法的优化"><a href="#diff-算法的优化" class="headerlink" title="diff 算法的优化"></a>diff 算法的优化</h2><p>由于 diff 算法本身会带来性能损耗，前后两颗树完全比对的算法复杂度为 O(n3)，其中 n 是树中元素的的数量。</p><p>为了降低算法复杂度，<code>React</code>的<code>diff</code>会预设三个限制：</p><ol><li>只对同级元素进行<code>Diff</code>。如果一个<code>DOM节点</code>在前后两次更新中跨越了层级，那么<code>React</code>不会尝试复用他。</li><li>两个不同类型的元素会产生出不同的树。如果元素由<code>div</code>变为<code>p</code>，React 会销毁<code>div</code>及其子孙节点，并新建<code>p</code>及其子孙节点。</li><li>开发者可以通过  <code>key prop</code>来暗示哪些子元素在不同的渲染下能保持稳定。</li></ol><p>考虑如下例子：</p><div class="hljs"><pre><code class="hljs html">// 更新前<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"ran"</span>&gt;</span>ran<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"xiu"</span>&gt;</span>xiu<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>// 更新后<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"xiu"</span>&gt;</span>xiu<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"ran"</span>&gt;</span>ran<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>如果没有<code>key</code>，<code>React</code>会认为<code>div</code>的第一个子节点由<code>p</code>变为<code>h1</code>，第二个子节点由<code>h1</code>变为<code>p</code>。这符合限制 2 的设定，会销毁并新建。</p><p>但是当我们用<code>key</code>指明了节点前后对应关系后，<code>React</code>知道<code>key === &quot;ran&quot;</code>的<code>p</code>在更新后还存在，所以<code>DOM节点</code>可以复用，只是需要交换下顺序。</p><p>reconcileChildFibers 函数会根据不同的 newChild（JSX 对象）调用不同的处理函数。</p><h2 id="单节点-diff"><a href="#单节点-diff" class="headerlink" title="单节点 diff"></a>单节点 diff</h2><p>当 newChild 类型为 object、number、string，代表同级只有一个节点。</p><ol><li>先判断 key 是否相同，然后 type，都相同时 DOM 才能复用。</li><li>当 child !== null 且 key 相同且 type 不同时，执行 deleteRemainingChildren 将 child 及其兄弟 fiber 都标记删除。</li><li>当 child !== null 且 key 不同时，仅将 child 标记删除。</li></ol><p>关于 2，3 步，当 key 相同但 type 不同，说明已经完全无法复用了，都需要删除。但 key 不同只代表该 fiber 不能复用，后面的兄弟 fiber 还有复用的可能性。</p><h2 id="多节点-diff"><a href="#多节点-diff" class="headerlink" title="多节点 diff"></a>多节点 diff</h2><p>当 newChild 类型为 Array，同级有多个节点。</p><p>多节点 diff 有多种情况需要处理</p><h3 id="1-节点更新"><a href="#1-节点更新" class="headerlink" title="1. 节点更新"></a>1. 节点更新</h3><p>节点更新又包含两种情况：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"p"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>// 属性变化<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"p"</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"p"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>// 类型变化<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"p"</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"p"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h3 id="2-节点新增或删除"><a href="#2-节点新增或删除" class="headerlink" title="2. 节点新增或删除"></a>2. 节点新增或删除</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"2"</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>// 新增<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"2"</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"3"</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>//删除<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h3 id="3-节点位置变化"><a href="#3-节点位置变化" class="headerlink" title="3. 节点位置变化"></a>3. 节点位置变化</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"2"</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>//<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"2"</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>不同的情况执行不同的逻辑，React 团队发现更新比其他两种的频率更高，于是 diff 优先判断更新情况。又因为 fiber 是单链表结构的，所以无法使用双指针优化遍历。diff 会经过两轮遍历：</p><ul><li>第一轮：处理更新节点。</li><li>第二轮：处理不为更新的节点。</li></ul><h2 id="React-中触发更新"><a href="#React-中触发更新" class="headerlink" title="React 中触发更新"></a>React 中触发更新</h2><p>除了 SSR 相关，触发更新的方法：</p><ul><li>ReactDOM.render</li><li>this.setState</li><li>this.forceUpdate</li><li>useState</li><li>useReducer</li></ul><h3 id="调度更新"><a href="#调度更新" class="headerlink" title="调度更新"></a>调度更新</h3><p>render 阶段从 rootFiber 开始向下遍历，触发更新的 fiber 调用 markUpdateLaneFromFiberToRoot 一直向上遍历到 rootFiber 并返回 rootFiber。触发更新的 fiber 中保存了一个 Update 的对象。</p><p>之后通知 Scheduler 根据更新的优先级，决定以同步还是异步的方式调度本次更新。</p><p><code>高优更新</code>中断正在进行中的<code>低优更新</code>，先完成<code>render - commit流程</code>。</p><p>待<code>高优更新</code>完成后，<code>低优更新</code>基于<code>高优更新</code>的结果<code>重新更新</code>。</p>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络测速</title>
    <link href="/2021/09/14/%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%80%9F/"/>
    <url>/2021/09/14/%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="前端如何测试网络的速度？"><a href="#前端如何测试网络的速度？" class="headerlink" title="前端如何测试网络的速度？"></a>前端如何测试网络的速度？</h2><p>B 站视频播放时有一个自动根据网络环境调整分辨率的功能，想了解如何测速<br><img src="/img/%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%80%9F/b.png" srcset="/img/loading.gif" alt="b站"></p><p>然后我找了下面的方法测速</p><h3 id="ajax-请求"><a href="#ajax-请求" class="headerlink" title="ajax 请求"></a>ajax 请求</h3><p>利用 XMLHttpRequest 请求返回的 Content-length，和请求所需时间求得下载速度</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getSpeed = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">window</span>.performance.now()    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()    xhr.open(<span class="hljs-string">"GET"</span>, url)    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;        <span class="hljs-keyword">const</span> time = (<span class="hljs-built_in">window</span>.performance.now() - start) / <span class="hljs-number">1000</span>        <span class="hljs-keyword">const</span> size = xhr.getResponseHeader(<span class="hljs-string">"Content-Length"</span>) / <span class="hljs-number">1024</span>        <span class="hljs-built_in">console</span>.log(time, size)        resolve(size / time)      &#125;    &#125;    xhr.send()  &#125;)&#125;getSpeed(<span class="hljs-string">"./worker.js"</span>).then(<span class="hljs-function">(<span class="hljs-params">speed</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(speed))</code></pre></div><p>请求我本地的文件测得速度：<br><img src="/img/%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%80%9F/speed.png" srcset="/img/loading.gif" alt="speed"></p><h3 id="Image-对象-onload"><a href="#Image-对象-onload" class="headerlink" title="Image 对象 onload"></a>Image 对象 onload</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getSpeed = <span class="hljs-function">(<span class="hljs-params">url, fileSize</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">window</span>.performance.now()    <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> Image()    img.src = url    img.onload = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> time = (<span class="hljs-built_in">window</span>.performance.now() - start) / <span class="hljs-number">1000</span>      resolve(fileSize / time)    &#125;  &#125;)&#125;</code></pre></div><p>但是要注意如果请求服务器的文件，建立请求也需要消耗时间，最好是多次请求取平均值。</p><h3 id="还有一个-downlink"><a href="#还有一个-downlink" class="headerlink" title="还有一个 downlink"></a>还有一个 downlink</h3><p><img src="/img/%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%80%9F/downlink.png" srcset="/img/loading.gif" alt="downlink"><br>downlink 的单位是 mbps, 所以要转化成 kb/s</p>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端错误监控</title>
    <link href="/2021/09/09/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/"/>
    <url>/2021/09/09/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="常见错误类型"><a href="#常见错误类型" class="headerlink" title="常见错误类型"></a>常见错误类型</h2><table><thead><tr><th>错误</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>SyntaxError</td><td>解析时发生语法错误</td><td>const x</td></tr><tr><td>TypeError</td><td>值不是所期待的类型</td><td>const person = 1; person.name</td></tr><tr><td>ReferenceError</td><td>引用未声明的变量</td><td>x</td></tr><tr><td>RangeError</td><td>一个值不在其所允许的范围中</td><td>new Array(-1)</td></tr><tr><td>ResourceError</td><td>资源加载错误</td><td>new Image().src = ‘/remote/null.jpg’</td></tr><tr><td>HttpError</td><td>http 请求错误</td><td>fetch(‘/remote/null’)</td></tr></tbody></table><h2 id="如何捕获错误"><a href="#如何捕获错误" class="headerlink" title="如何捕获错误"></a>如何捕获错误</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h3><p>能够捕获常规运行时错误，语法错误和异步错误无法捕获</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 常规运行时错误，可以捕获 ✅</span><span class="hljs-keyword">try</span> &#123;  <span class="hljs-built_in">console</span>.log(notdefined);&#125; <span class="hljs-keyword">catch</span>(e) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>, e);&#125;<span class="hljs-comment">// 语法错误，不能捕获 ❌</span><span class="hljs-keyword">try</span> &#123;  <span class="hljs-keyword">const</span> notdefined,&#125; <span class="hljs-keyword">catch</span>(e) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>, e);&#125;<span class="hljs-comment">// 异步错误，不能捕获 ❌</span><span class="hljs-keyword">try</span> &#123;  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(notdefined);  &#125;, <span class="hljs-number">0</span>)&#125; <span class="hljs-keyword">catch</span>(e) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,e);&#125;</code></pre></div><h3 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h3><blockquote><p>混合事件 GlobalEventHandlers 的 onerror 属性是用于处理 error 的事件<br>Error 事件的事件处理程序，在各种目标对象的不同类型错误被触发：</p></blockquote><blockquote><ul><li>当 JavaScript 运行时错误（包括语法错误）发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。</li><li>当一项资源（如&lt;img&gt;或&lt;script&gt;）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window，不过（至少在 Firefox 中）能被单一的 window.addEventListener 捕获。</li></ul></blockquote><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123; ... &#125;</code></pre></div><p>函数参数：</p><ul><li>message：错误信息（字符串）。可用于 HTML onerror=””处理程序中的 event。</li><li>source：发生错误的脚本 URL（字符串）</li><li>lineno：发生错误的行号（数字）</li><li>colno：发生错误的列号（数字）</li><li>error：Error 对象（对象）</li></ul><p>若该函数返回 true，则阻止执行默认事件处理函数。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 常规运行时错误，可以捕获 ✅</span><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);&#125;<span class="hljs-built_in">console</span>.log(notdefined);<span class="hljs-comment">// 语法错误，不能捕获 ❌</span><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);&#125;<span class="hljs-keyword">const</span> notdefined,<span class="hljs-comment">// 异步错误，可以捕获 ✅</span><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);&#125;setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(notdefined);&#125;, <span class="hljs-number">0</span>)<span class="hljs-comment">// 资源错误，不能捕获 ❌</span>&lt;script&gt;  <span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, source, lineno, colno, error</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&lt;<span class="hljs-regexp">/script&gt;</span><span class="hljs-regexp">&lt;img src="https:/</span><span class="hljs-regexp">/unknown/im</span>age/<span class="hljs-literal">null</span>.png<span class="hljs-string">"&gt;</span></code></pre></div><h3 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h3><div class="hljs"><pre><code class="hljs html">// 图片、script、css加载错误，都能被捕获 ✅<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-built_in">window</span>.addEventListener(</span><span class="actionscript">    <span class="hljs-string">"error"</span>,</span>    (error) =&gt; &#123;<span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"捕获到异常："</span>, error)</span>    &#125;,<span class="actionscript">    <span class="hljs-literal">true</span></span>  )<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unknown/image/null.png"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unknown/foundnull.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://unknown/foundnull.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> /&gt;</span>// new Image错误，不能捕获 ❌<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-built_in">window</span>.addEventListener(</span><span class="actionscript">    <span class="hljs-string">"error"</span>,</span>    (error) =&gt; &#123;<span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"捕获到异常："</span>, error)</span>    &#125;,<span class="actionscript">    <span class="hljs-literal">true</span></span>  )<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  <span class="hljs-keyword">new</span> Image().src = <span class="hljs-string">"https://unknown/image/null.png"</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>// fetch错误，不能捕获 ❌<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-built_in">window</span>.addEventListener(</span><span class="actionscript">    <span class="hljs-string">"error"</span>,</span>    (error) =&gt; &#123;<span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"捕获到异常："</span>, error)</span>    &#125;,<span class="actionscript">    <span class="hljs-literal">true</span></span>  )<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  fetch(<span class="hljs-string">"https://unknown/test"</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h3 id="异步错误"><a href="#异步错误" class="headerlink" title="异步错误"></a>异步错误</h3><p>如果使用 try/catch 能捕获 await 的错误<br>普通 Promise 错误 使用 catch</p><h3 id="全局捕获错误-unhandledrejection"><a href="#全局捕获错误-unhandledrejection" class="headerlink" title="全局捕获错误 - unhandledrejection"></a>全局捕获错误 - unhandledrejection</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 全局统一处理Promise</span><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"unhandledrejection"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"捕获到异常："</span>, e)&#125;)fetch(<span class="hljs-string">"https://unknown/test"</span>)</code></pre></div><h3 id="Vue-的错误"><a href="#Vue-的错误" class="headerlink" title="Vue 的错误"></a>Vue 的错误</h3><p>vue 的错误会被 vue 自动捕获，并且抛给 Vue.config.errorHandler。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 全局捕获Vue错误，直接扔出给onerror处理</span><span class="hljs-comment"> */</span>Vue.config.errorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">throw</span> err  &#125;)&#125;</code></pre></div><h3 id="React-错误"><a href="#React-错误" class="headerlink" title="React 错误"></a>React 错误</h3><p>react 通过 componentDidCatch，声明一个错误边界的组件</p><h2 id="数据上报接口"><a href="#数据上报接口" class="headerlink" title="数据上报接口"></a>数据上报接口</h2><p>使用 1*1 像素的 gif 图片进行上报，有以下几点好处</p><ul><li>不会阻塞页面渲染</li><li>图片天然跨域</li><li>不会携带 Cookie</li><li>不需等待服务器返回数据</li><li>gif 图片所需流量最小</li></ul><p>但数据太大，最好还是用 post</p>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React memo lazy</title>
    <link href="/2021/09/09/React-memo-lazy/"/>
    <url>/2021/09/09/React-memo-lazy/</url>
    
    <content type="html"><![CDATA[<h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><p>react.memo 有第二个参数，可以通过第二个参数来自定义组件的渲染时机。</p><div class="hljs"><pre><code class="hljs jsx">React.memo(Component, compare)</code></pre></div><p>React.memo 接受两个参数，第一个参数 Component 原始组件本身，第二个参数 compare 是一个函数，可以根据一次更新中 props 是否相同决定原始组件是否重新渲染。</p><p>memo 的几个特点是：</p><ul><li><p>React.memo: 第二个参数 返回 true 组件不渲染 ， 返回 false 组件重新渲染。<br>和 shouldComponentUpdate 相反，shouldComponentUpdate : 返回 true 组件渲染 ， 返回 false 组件不渲染。</p></li><li><p>memo 当二个参数 compare 不存在时，会用浅比较原则处理 props ，相当于仅比较 props 版本的 pureComponent 。</p></li><li><p>memo 同样适合类组件和函数组件。<br>关于第二个参数你可以这样写：</p></li></ul><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> compare = <span class="hljs-function">(<span class="hljs-params">prev, next</span>) =&gt;</span>  prev.number === next.number ||  (prev.number !== next.number &amp;&amp; next.number &gt; <span class="hljs-number">1</span>)</code></pre></div><p>这里有两个意思：</p><ul><li>number 改变时 组件渲染</li><li>number 小于 1 时 组件渲染</li></ul><h2 id="关于-rander"><a href="#关于-rander" class="headerlink" title="关于 rander"></a>关于 rander</h2><h3 id="有没有必要在乎组件不必要渲染。"><a href="#有没有必要在乎组件不必要渲染。" class="headerlink" title="有没有必要在乎组件不必要渲染。"></a>有没有必要在乎组件不必要渲染。</h3><p>在正常情况下，无须过分在乎 React 没有必要的渲染，执行 render 不等于真正的浏览器渲染视图，render 阶段执行是在 js 当中，js 中运行代码远快于浏览器的 Rendering 和 Painting 的，更何况 React 还提供了 diff 算法等手段，去复用真实 DOM 。</p><h3 id="什么时候需要注意渲染节流。"><a href="#什么时候需要注意渲染节流。" class="headerlink" title="什么时候需要注意渲染节流。"></a>什么时候需要注意渲染节流。</h3><p>但是对于以下情况，值得开发者注意，需要采用渲染节流：</p><ul><li>第一种情况数据可视化的模块组件（展示了大量的数据），这种情况比较小心因为一次更新，可能伴随大量的 diff ，数据量越大也就越浪费性能，所以对于数据展示模块组件，有必要采取 memo ， shouldComponentUpdate 等方案控制自身组件渲染。</li><li>第二种情况含有大量表单的页面，React 一般会采用受控组件的模式去管理表单数据层，表单数据层完全托管于 props 或是 state ，而用户操作表单往往是频繁的，需要频繁改变数据层，所以很有可能让整个页面组件高频率 render 。</li><li>第三种情况就是越是靠近 app root 根组件越值得注意，根组件渲染会波及到整个组件树重新 render ，子组件 render ，一是浪费性能，二是可能执行 useEffect ，componentWillReceiveProps 等钩子，造成意想不到的情况发生。</li></ul><h2 id="使用-Suspense-和-React-lazy-模拟实现异步加载组件"><a href="#使用-Suspense-和-React-lazy-模拟实现异步加载组件" class="headerlink" title="使用 Suspense 和 React.lazy 模拟实现异步加载组件"></a>使用 Suspense 和 React.lazy 模拟实现异步加载组件</h2><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><ul><li>异步请求数据，请求完数据挂载组件，请求过程中展示 loading 效果。</li><li>全程组件只渲染一次</li></ul><h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AsyncComp</span>(<span class="hljs-params">Comp, asyncFn</span>) </span>&#123;  <span class="hljs-keyword">const</span> AsyncCompPromise = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve) =&gt; &#123;      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> asyncFn()      resolve(&#123;        <span class="hljs-keyword">default</span>: <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Comp</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;data&#125;</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>,      &#125;)    &#125;)  <span class="hljs-keyword">return</span> React.lazy(AsyncCompPromise)&#125;<span class="hljs-keyword">const</span> fetchData = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      resolve(&#123;        name: <span class="hljs-string">"ranxiu"</span>,        msg: <span class="hljs-string">"a lot of data"</span>,      &#125;)    &#125;, <span class="hljs-number">1000</span>)  &#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span>(<span class="hljs-params">&#123; value, gender &#125;</span>) </span>&#123;  <span class="hljs-keyword">const</span> &#123; name, msg &#125; = value  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;div&gt;my name is &#123;name&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">      &lt;div&gt;this is &#123;msg&#125;&lt;/</span>div&gt;      &lt;div&gt;my gender is &#123;gender&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">    &lt;/</span>div&gt;  )&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> LzayTest = AsyncComp(Test, fetchData)  <span class="hljs-keyword">return</span> (    &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;<span class="hljs-regexp">/div&gt;&#125;&gt;</span><span class="hljs-regexp">      &lt;LzayTest gender='男' /</span>&gt;    &lt;<span class="hljs-regexp">/Suspense&gt;</span><span class="hljs-regexp">  )</span><span class="hljs-regexp">&#125;</span></code></pre></div><p>React.lazy 要求函数需要返回一个 Promise。大致流程是，react.lazy 第一次渲染时会向外抛个异常 Promise，这个异常会被 Suspense 捕获到，Suspense 处理 Promise，Promise 执行成功后 Susponse 发起渲染，返回真正需要渲染的组件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Props Children 混合插槽</title>
    <link href="/2021/09/09/React-Props-Children-%E6%B7%B7%E5%90%88%E6%8F%92%E6%A7%BD/"/>
    <url>/2021/09/09/React-Props-Children-%E6%B7%B7%E5%90%88%E6%8F%92%E6%A7%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="当多种-children-一起输入时"><a href="#当多种-children-一起输入时" class="headerlink" title="当多种 children 一起输入时"></a>当多种 children 一起输入时</h2><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Container</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">const</span> defaultProps = &#123;    name: <span class="hljs-string">"alen"</span>,    msg: <span class="hljs-string">"hello"</span>,  &#125;  <span class="hljs-keyword">return</span> props.children.map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 通过判断 clone 混入props</span>    <span class="hljs-keyword">if</span> (React.isValidElement(item)) &#123;      <span class="hljs-keyword">return</span> React.cloneElement(item, &#123; ...defaultProps &#125;)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">"function"</span>) &#123;      <span class="hljs-keyword">return</span> item(defaultProps)    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    &#125;  &#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;props.name + props.msg&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    &lt;Container&gt;      <span class="hljs-comment">// 多种方式混入</span>      &lt;Child /&gt;      &#123;(props) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>&#125;    &lt;<span class="hljs-regexp">/Container&gt;</span><span class="hljs-regexp">  )</span><span class="hljs-regexp">&#125;</span><span class="hljs-regexp"></span><span class="hljs-regexp">render(&lt;App /</span>&gt;, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"root"</span>))</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>createObjectURL</title>
    <link href="/2021/09/08/%E5%85%B3%E4%BA%8EcreateObjectURL/"/>
    <url>/2021/09/08/%E5%85%B3%E4%BA%8EcreateObjectURL/</url>
    
    <content type="html"><![CDATA[<h2 id="createObjectURL-是什么"><a href="#createObjectURL-是什么" class="headerlink" title="createObjectURL 是什么"></a>createObjectURL 是什么</h2><blockquote><p>URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的 URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的 URL 对象表示指定的 File 对象或 Blob 对象。 — MDN</p></blockquote><h2 id="Blob-URL-Object-URL"><a href="#Blob-URL-Object-URL" class="headerlink" title="Blob URL/Object URL"></a>Blob URL/Object URL</h2><p>Blob URL/Object URL 是⼀种伪协议，允许 Blob 和 File 对象⽤作图像，下载⼆进制数据链接等的 URL<br>源。在浏览器中，我们使⽤ URL.createObjectURL ⽅法来创建 Blob URL，该⽅法接收⼀个 Blob 对<br>象，并为其创建⼀个唯⼀的 URL，其形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code> ，对应的示例如下：</p><div class="hljs"><pre><code class="hljs js">blob:https:<span class="hljs-comment">//example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641</span></code></pre></div><p>浏览器内部为每个通过 URL.createObjectURL ⽣成的 URL 存储了⼀个 URL → Blob 映射。因此，此<br>类 URL 较短，但可以访问 Blob 。⽣成的 URL 仅在当前⽂档打开的状态下才有效。它允许引⽤<br><code>&lt;img&gt; 、 &lt;a&gt;</code> 中的 Blob ，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。</p><p>上述的 Blob URL 看似很不错，但实际上它也有副作⽤。虽然存储了 URL → Blob 的映射，但 Blob 本<br>身仍驻留在内存中，浏览器⽆法释放它。映射在⽂档卸载时⾃动清除，因此 Blob 对象随后被释放。但<br>是，如果应⽤程序寿命很⻓，那不会很快发⽣。因此，如果我们创建⼀个 Blob URL，即使不再需要该<br>Blob，它也会存在内存中。</p><p>针对这个问题，我们可以调⽤ URL.revokeObjectURL(url) ⽅法，从内部映射中删除引⽤，从⽽允许<br>删除 Blob（如果没有其他引⽤），并释放内存。</p><h2 id="createObjectURL-可以用来做什么"><a href="#createObjectURL-可以用来做什么" class="headerlink" title="createObjectURL 可以用来做什么"></a>createObjectURL 可以用来做什么</h2><p>比如显示上传的预览图</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><span class="hljs-tag">    <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span></span><span class="hljs-tag">    <span class="hljs-attr">multiple</span></span><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">"fileInput"</span></span><span class="hljs-tag">    <span class="hljs-attr">onchange</span>=<span class="hljs-string">"previewFiles(this.files)"</span></span><span class="hljs-tag">  /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"preview"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">const</span> inputEl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'fileInput'</span>) <span class="hljs-keyword">const</span> ulEle =</span><span class="javascript">    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'preview'</span>) <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">previewFiles</span>(<span class="hljs-params">files</span>)</span>&#123;<span class="hljs-string">" "</span>&#125;</span><span class="javascript">    &#123;<span class="hljs-built_in">Array</span>.from(files).forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;</span><span class="javascript">      <span class="hljs-keyword">const</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"li"</span>)</span>      ulEle.appendChild(li)<span class="javascript">      <span class="hljs-keyword">const</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"img"</span>)</span>      img.src = URL.createObjectURL(file)      img.height = 100      img.width = 100<span class="actionscript">      img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span><span class="actionscript">        <span class="hljs-comment">// 当图片加载完成之后对象URL就不再需要了</span></span><span class="actionscript">        URL.revokeObjectURL(<span class="hljs-keyword">this</span>.src)</span>      &#125;      li.appendChild(img)    &#125;)&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>来看看效果：</p><p><img src="/img/createObjectURL/1.png" srcset="/img/loading.gif" alt="效果"></p><blockquote><p>在每次调用  <code>createObjectURL()</code>  方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL" target="_blank" rel="noopener">URL.revokeObjectURL()</a> 方法来释放。</p></blockquote><p>浏览器在 document 卸载的时候，会自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。</p><h2 id="FileReader-的-readAsDataURL"><a href="#FileReader-的-readAsDataURL" class="headerlink" title="FileReader 的 readAsDataURL"></a>FileReader 的 readAsDataURL</h2><blockquote><p>readAsDataURL 方法会读取指定的 Blob 或 File 对象。读取操作完成的时候，readyState 会变成已完成 DONE，并触发 loadend 事件，同时 result 属性将包含一个 data:URL 格式的字符串（base64 编码）以表示所读取文件的内容。</p></blockquote><p>还是上一个例子</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFileReaderPreivewFiles</span>(<span class="hljs-params">files</span>) </span>&#123;  <span class="hljs-built_in">Array</span>.from(files).forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> FileReader()    <span class="hljs-keyword">const</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"li"</span>)    ulEle.appendChild(li)    reader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;      <span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> Image()      img.height = <span class="hljs-number">100</span>      img.width = <span class="hljs-number">100</span>      img.src = e.target.result      li.appendChild(img)    &#125;    reader.readAsDataURL(file)  &#125;)&#125;</code></pre></div><p>同样的效果:</p><p><img src="/img/createObjectURL/2.png" srcset="/img/loading.gif" alt="效果图"></p><p>来一张终极图：</p><p><img src="/img/createObjectURL/3.jpg" srcset="/img/loading.gif" alt="data_url.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型与原型链</title>
    <link href="/2021/09/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2021/09/07/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><p><strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</strong></p><p>每个函数都有一个属性，就是 prototype，函数的 prototype 指向了一个对象，这个对象就是调用该构造函数创建的<strong>实例</strong>的原型。</p><p>可以这么理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。实例 person 与 Person.prototype 之间的关系通过 <strong>proto</strong> 连接这是每一个 JavaScript 对象(除了 null )都具有的一个属性，叫<strong>proto</strong>，这个属性会指向该对象的原型。</p><p><img src="/img/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image1.png" srcset="/img/loading.gif" alt="原型"></p><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<span class="hljs-built_in">console</span>.log(person.__proto__ === Person.prototype) <span class="hljs-comment">// true</span></code></pre></div><p><img src="/img/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image2.png" srcset="/img/loading.gif" alt="原型"></p><p>每个原型都有一个 <strong>constructor</strong> 属性指向关联的构造函数。</p><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-built_in">console</span>.log(Person === Person.prototype.constructor) <span class="hljs-comment">// true</span></code></pre></div><p><img src="/img/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image3.png" srcset="/img/loading.gif" alt="原型"></p><p>原型也是一个对象，那就可以通过 Object 构造函数生成，所以</p><p><img src="/img/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image4.png" srcset="/img/loading.gif" alt="原型"></p><p>Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><p><img src="/img/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image5.png" srcset="/img/loading.gif" alt="原型"></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<span class="hljs-built_in">console</span>.log(person.constructor === Person) <span class="hljs-comment">// true</span></code></pre></div><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p><div class="hljs"><pre><code class="hljs jsx">person.constructor === Person.prototype.constructor</code></pre></div><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p><h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是：</p><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p><h3 id="Function-proto-Function-prototype"><a href="#Function-proto-Function-prototype" class="headerlink" title="Function.proto === Function.prototype"></a>Function.<strong>proto</strong> === Function.prototype</h3><p>Function 作为一个内置对象，是运行前就已经存在的东西，所以根本就不会根据自己生成自己，就是先有的 Function，然后实现上把原型指向了 Function.prototype，但是我们不能倒过来推测因为 Function.<strong>proto</strong> === Function.prototype，所以 Function 调用了自己生成了自己。</p><h3 id="完整的原型链"><a href="#完整的原型链" class="headerlink" title="完整的原型链"></a>完整的原型链</h3><p><img src="/img/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image6.png" srcset="/img/loading.gif" alt="原型"></p><p><strong>什么是原型链？</strong></p><p>当对象查找一个属性的时候，如果没有在自身找到，那么就会查找自身的原型，如果原型还没有找到，那么会继续查找原型的原型，直到找到 Object.prototype 的原型时，此时原型为 null，查找停止。 这种通过<strong>原型链接的逐级向上的查找链</strong>被称为原型链</p><p><strong>什么是原型继承？</strong></p><p>一个对象可以使用另外一个对象的属性或者方法，就称之为继承。具体是通过将这个对象的原型设置为另外一个对象，这样根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找另外一个对象，相当于一个对象可以使用另外一个对象的属性和方法了。</p><p>使用 <strong>Object.prototype.toString.call()</strong> 判断数据类型</p><p><strong>proto</strong> 与内部的 <strong>[[Prototype]] 不一样</strong>。</p><p><strong>proto</strong> 是 <strong>[[Prototype]]</strong> 的 getter/setter。</p>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚假的洗牌算法</title>
    <link href="/2021/08/31/%E8%99%9A%E5%81%87%E7%9A%84%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2021/08/31/%E8%99%9A%E5%81%87%E7%9A%84%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="虚假的洗牌算法"><a href="#虚假的洗牌算法" class="headerlink" title="虚假的洗牌算法"></a>虚假的洗牌算法</h2><p>最常见的：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> shuffle = <span class="hljs-function">(<span class="hljs-params">list</span>) =&gt;</span> list.sort(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span>)</code></pre></div><p>可这并不合理，对于这个数组：[1,2,3,4,5]，每个数字出现在每个位置的概率应该是相同的。然而使用以上算法，1 出现在 index=4 位置的概率 与 4 出现在 index=4 的概率并不相同。</p><h2 id="真正的洗牌算法"><a href="#真正的洗牌算法" class="headerlink" title="真正的洗牌算法"></a>真正的洗牌算法</h2><p><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank" rel="noopener">Fisher–Yates shuffle</a></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nums = <span class="hljs-built_in">Array</span>(<span class="hljs-number">54</span>)  .fill(<span class="hljs-literal">undefined</span>)  .map(<span class="hljs-function">(<span class="hljs-params">_, index</span>) =&gt;</span> index)<span class="hljs-comment">/**</span><span class="hljs-comment"> * 洗牌算法</span><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>nums 数组</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FYSufffle</span>(<span class="hljs-params">nums</span>) </span>&#123;  <span class="hljs-keyword">const</span> randNums = <span class="hljs-built_in">Array</span>.from(nums)  <span class="hljs-keyword">let</span> len = nums.length  <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">const</span> rand = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * len)    len--    <span class="hljs-comment">// 交换</span>    ;[randNums[rand], randNums[len]] = [randNums[len], randNums[rand]]  &#125;  <span class="hljs-keyword">return</span> randNums&#125;<span class="hljs-built_in">console</span>.log(FYSufffle(nums))</code></pre></div><p>以上。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>洗牌</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于实习的记忆</title>
    <link href="/2021/08/28/%E5%85%B3%E4%BA%8E%E5%AE%9E%E4%B9%A0%E7%9A%84%E8%AE%B0%E5%BF%86/"/>
    <url>/2021/08/28/%E5%85%B3%E4%BA%8E%E5%AE%9E%E4%B9%A0%E7%9A%84%E8%AE%B0%E5%BF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="关于实习的记忆"><a href="#关于实习的记忆" class="headerlink" title="关于实习的记忆"></a>关于实习的记忆</h1><h2 id="4-21-相遇"><a href="#4-21-相遇" class="headerlink" title="4.21 相遇"></a>4.21 相遇</h2><p>关于这天，我记住的不多了，只是记得当天与我同时入职的有不少人，有一个从广东过来的小哥，穿着一身帅气西装，把头发梳成大人模样。</p><p>当时我的 mentor 时中正在开会，后来才知道是站会，我的 leader 飞哥过来把我领到我的座位上。然后开始按照入职须知安装软件，安装一半时，我的 mentor 开完会回来了。说实话，第一眼看见时中时，与我内心的形象很相近，除了发际线。第一次见面总有些拘束，时中也有些拘束，我问我需要先干什么，时中只是让我按照须知先安装软件。中午去一起吃了一个饭。</p><h2 id="5-6-熟悉"><a href="#5-6-熟悉" class="headerlink" title="5-6 熟悉"></a>5-6 熟悉</h2><p>慢慢开始熟悉周围的人，熟悉会议、迭代、开发、部署等等流程。来了一个新伙伴耀辉，当时的第一记忆是：为什么不叫辉耀。之后慢慢跟耀辉熟悉，发现他的几个特点，比如 喜欢说“我比较好奇”，很“正式”，努力，还有想找女朋友。真是优秀的男生啊。</p><p>这个节点同时也是我快速成长的阶段。</p><p>开发时的全局代码考虑，代码的优雅写法，设计模式的应用等等。对一个稍大型的项目应该如何组织代码，对代码进行复用。对一些其他的技术的了解，时中对于技术的不懈追求也影响了我很多，总是对一些新的技术主动尝试，了解，发现其优缺点。</p><h2 id="7-8-合作"><a href="#7-8-合作" class="headerlink" title="7-8 合作"></a>7-8 合作</h2><p>真正的负责一个部分的需求，多个需求的并行开发。与视觉交互产品沟通业务需求，改进用户体验，同后端奥瓜联调测试。在这个阶段才开始真正的像一个开发者，像团队的一部分，而不是一个旁观者。开始发现一些开发过程中的问题，发挥主观能动性。</p><h2 id="8-27-离别"><a href="#8-27-离别" class="headerlink" title="8.27 离别"></a>8.27 离别</h2><p>难得是欢聚，唯有别离多。</p><p>离别总是伤感的，我总是不去想它，但真正到达的那一刻还是会难受。</p><p>习惯的力量是很大的，我习惯了每天早上 8 点多到公司，我习惯了每天中午吃完饭跟时中吹牛打屁，我习惯了晚上回家后打开空调去洗澡然后开罐汽水，习惯了吃西斗门路的木桶饭，牛肉汤，善当家…</p><p>成长路上总会经历这些，只能怀着感恩的心继续前行。</p><p>感谢 我的 mentor 时中</p><p>感谢 耀辉，飞哥，洋葱，吴用，奥瓜，十禾等等对我的支持和帮助。</p>]]></content>
    
    
    
    <tags>
      
      <tag>实习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron和react关联开发使用的小工具</title>
    <link href="/2021/04/14/electron%E5%92%8Creact%E5%85%B3%E8%81%94%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/2021/04/14/electron%E5%92%8Creact%E5%85%B3%E8%81%94%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="concurrently"><a href="#concurrently" class="headerlink" title="concurrently"></a>concurrently</h2><p>当执行多个命令时使用，跨平台，输出友好。<br>如：</p><div class="hljs"><pre><code class="hljs json">"dev": "concurrently \"wait-on http://localhost:3000 &amp;&amp; electron .\" \"cross-env BROWSER=none npm start\"",</code></pre></div><h2 id="wait-on"><a href="#wait-on" class="headerlink" title="wait-on"></a>wait-on</h2><p>等待文件，端口，网络资源就绪后执行命令。<br>如：</p><div class="hljs"><pre><code class="hljs json">"dev": "concurrently \"wait-on http://localhost:3000 &amp;&amp; electron .\" \"cross-env BROWSER=none npm start\"",</code></pre></div><p>等待3000端口内容就绪后执行<code>electron .</code>。</p><h2 id="cross-env"><a href="#cross-env" class="headerlink" title="cross-env"></a>cross-env</h2><p>跨平台设置环境变量</p><div class="hljs"><pre><code class="hljs json">cross-env BROWSER=none npm start</code></pre></div><p>执行后面的命令时不打开浏览器</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>requestAnimationFrame思考</title>
    <link href="/2021/04/08/requestAnimationFrame%E6%80%9D%E8%80%83/"/>
    <url>/2021/04/08/requestAnimationFrame%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="关于setTimeout"><a href="#关于setTimeout" class="headerlink" title="关于setTimeout"></a>关于setTimeout</h2><p>首先要明白，setTimeout 的执行只是在内存中对元素属性进行改变，这个变化必须要等到屏幕下次绘制时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素。假设屏幕每隔16.7ms刷新一次，而setTimeout 每隔10ms设置图像向左移动1px， 就会出现如下绘制过程（表格）：</p><ul><li>第    0  ms：屏幕未绘制，  等待中，setTimeout 也未执行，等待中；</li><li>第   10 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置元素属性 left=1px；</li><li>第 16.7 ms：屏幕开始绘制，屏幕上的元素向左移动了 1px， setTimeout 未执行，继续等待中；</li><li>第   20 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=2px;</li><li>第   30 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=3px;</li><li>第33.4 ms：屏幕开始绘制，屏幕上的元素向左移动了 3px， setTimeout 未执行，继续等待中；<br>…</li></ul><p>从上面的绘制过程中可以看出，屏幕没有更新 left=2px 的那一帧画面，元素直接从left=1px 的位置跳到了 left=3px 的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。</p><h2 id="关于requestAnimationFrame"><a href="#关于requestAnimationFrame" class="headerlink" title="关于requestAnimationFrame"></a>关于requestAnimationFrame</h2><p>与 setTimeout 相比，rAF 最大的优势是 由系统来决定回调函数的执行时机。具体一点讲就是，<code>系统每次绘制之前会主动调用 rAF 中的回调函数</code>，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。换句话说就是，rAF 的执行步伐跟着系统的绘制频率走。<code>它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次</code>，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p><p><strong><em>但是rAF并不能保证每次绘制都会执行,如果有个计算任务执行了  20ms，那么再一次回调会在 16.7 * 3 ms时执行，跳过了一次绘制。16.7+20 = 36.7，36.7+16.7 = 53.4， 16.7 * 3 = 50.1, 50.1&lt;53.4</em></strong></p><h2 id="rAF的优势"><a href="#rAF的优势" class="headerlink" title="rAF的优势"></a>rAF的优势</h2><ul><li><p>CPU节能：使用 setTimeout 实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，而且还浪费 CPU 资源。而 rAF 则完全不同，当页面处理未激活的状态下，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的 rAF 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。</p></li><li><p>函数节流：在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用 rAF 可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个绘制间隔内函数执行多次时没有意义的，因为显示器每16.7ms 绘制一次，多次绘制并不会在屏幕上体现出来。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="/2021/04/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2021/04/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>• 第一次握手([SYN], Seq = x)<br>客户端发送一个SYN标记的包，Seq初始序列号x，发送完成后客户端进入SYN_SEND状态。<br>• 第二次握手([SYN,ACK], Seq = y, ACK = x + 1)<br>服务器返回确认包(ACK)应答，同时还要发送一个SYN包回去。ACK = x + 1,表示确认收到(客户端发来的Seq值 + 1)，Seq = y, 表示让客户端确认是否能收到。发送完成后服务端进入SYN_RCVD状态。<br>• 第三次握手([ACK], ACK = y + 1)<br>客户端再次发送确认包(ACK),ACK = y + 1, 表示确认收到服务器的包（服务端发来的Seq值 + 1）。客户端发送完毕后，进入ESTABLISHED状态，服务端接收到这个包，也进入ESTABLISHED状态, TCP握手结束。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>• 第一次挥手（[FIN], Seq = x）<br>客户端发送一个FIN标记的包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据。发送完成后，客户端进入FIN_WAIT_1状态。<br>• 第二次挥手 ([ACK], ACK = x + 1)<br>服务端发送一个ACK的确认包，告诉客户端接收到关闭的请求，但是还没有准备好。发送完成后，服务端进入CLOSE_WAIT状态，客户端收到这个包后，进入FIN_WAIT_2，等待服务器关闭连接。<br>• 第三次挥手 ([FIN], Seq = y)<br>服务端准备好关闭连接时，发送FIN标记的包，告诉客户端准备关闭了。发送完成后，服务端进入LAST_ACK状态，等待客户端确认。<br>• 第四次挥手 ([ACK], ACK = y + 1)<br>客户端接收到服务端的关闭请求，再发送ACK标记的确认包，进入TIME_WAIT状态，等待服务端可能请求重传的ACK包。<br>服务端接收到ACK包后，关闭连接，进入CLOSED状态。<br>客户端在等待固定时间(两个最大段生命周期)后，没有接收到服务的ACK包，认为服务器已关闭连接，自己也关闭连接，进入CLOSED状态。<br>###　为什么三次握手<br>“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue在style中使用變量</title>
    <link href="/2020/12/31/vue%E5%9C%A8style%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%8A%E9%87%8F/"/>
    <url>/2020/12/31/vue%E5%9C%A8style%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%8A%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="在style中使用js变量"><a href="#在style中使用js变量" class="headerlink" title="在style中使用js变量"></a>在style中使用js变量</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"styleVar"</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  props: &#123;    height: &#123;<span class="javascript">      type: <span class="hljs-built_in">Number</span>,</span><span class="actionscript">      <span class="hljs-keyword">default</span>: <span class="hljs-number">54</span>,</span>    &#125;,  &#125;,  computed: &#123;    styleVar() &#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">        <span class="hljs-string">'--box-height'</span>: <span class="hljs-keyword">this</span>.height + <span class="hljs-string">'px'</span></span>      &#125;    &#125;  &#125;,&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css"><span class="hljs-selector-class">.box</span> &#123;</span>  height: var(--box-height);&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>将变量在行内注入，在style中使用var获取js变量。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>betterscroll的refresh问题</title>
    <link href="/2020/11/30/betterscroll%E7%9A%84refresh%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/30/betterscroll%E7%9A%84refresh%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="betterscroll-在数据更新时问题"><a href="#betterscroll-在数据更新时问题" class="headerlink" title="betterscroll 在数据更新时问题"></a>betterscroll 在数据更新时问题</h2><p>由于 <code>betterscroll的实例化要先于我动态设置wrapper的高度</code><br>导致betterscroll开始计算时的内高和外容器高度一致，<code>hasVerticalScroll</code> 的值为 <code>false</code>  。需要在页面更新后refresh一下。最后通过在 update 钩子函数中增加 betterScroll 的refresh 方法，成功实现滚动效果。<br>update 函数官网是这样说的:</p><blockquote><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。</p></blockquote><p>异步获取数据渲染到页面上时，调用该钩子来重新计算 bs 实例，如果不在update 钩子里调用 refresh 方法，hasVerticalScroll 的值是false。导致:最后的高度<code>看似</code>计算正确，就是不能滑动。其实是因为 我是动态设置的wrapper的高度，因为不是绝对定位，需要先获得标题栏高度，才能算出 <code>scrollwrapper</code> 的高度。</p>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>better-scroll结合vue遇到图片引起的问题</title>
    <link href="/2020/11/30/better-scroll%E7%BB%93%E5%90%88vue%E9%81%87%E5%88%B0%E5%9B%BE%E7%89%87%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/30/better-scroll%E7%BB%93%E5%90%88vue%E9%81%87%E5%88%B0%E5%9B%BE%E7%89%87%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="使用better-scroll遇到的问题"><a href="#使用better-scroll遇到的问题" class="headerlink" title="使用better-scroll遇到的问题"></a>使用better-scroll遇到的问题</h2><p>原来项目中只使用了better-scroll来做轮播图和滑动组件，但是头部和标签栏是固定的，只滑动下面部分，于是设置 scroll-warpper样式如下：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.scroll-wrapper</span> &#123;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">top</span>: <span class="hljs-number">80px</span>;  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;&#125;</code></pre></div><p>但是想要实现下部组件与上部标签的联动，仅仅靠better-scroll就不够了，于是项目中按需引入了vant的的标签组件，来实现移动端的左右滑动（不得不说，封装好的东西就是香）。紧接着就产生了问题，</p><ul><li>一是：下部组件无法滑动，</li><li>二是：better-scroll滑不到底部，只能滑一部分。刷新页面后可以滑动了</li></ul><p>分析问题：</p><ul><li>查看dom发现vant的content__wrap没有高度，而scroll-warpper和内容高度一致。这是由于content__wrap的定位是relative，而scroll-wrapper是相对于content__wrap而定位的，并不是相对整个页面定位，所有内容是被里面撑开的。</li><li>页面中有大量图片，当dom加载完成后图片并没有加载完成，scroll已经初始化了，所以滑不到底部。刷新页面可以滑动是因为图片已经被浏览器缓存了，刷新直接拿到图片不需要重新请求。</li></ul><p>解决问题：</p><ul><li>第一个问题是定位的原因，那我们把wrapper的高度写死就好了，<br>但是由于头部和标签是自适应的，高度是不确定的，就没法写死了。使用动态获取设置wrapper的style：<div class="hljs"><pre><code class="hljs js">setScrollWrapperHeight() &#123;      <span class="hljs-keyword">this</span>.$refs.scroll.$el.style.height =        <span class="hljs-built_in">window</span>.innerHeight - <span class="hljs-keyword">this</span>.topHeight + <span class="hljs-string">'px'</span>    &#125;,</code></pre></div><ul><li>由于多个页面都需要这个配置，放到mixin中，在mounted方法中调用此方法。<br>解决wrapper高度问题。</li><li>第二个问题是图片加载时content的高度设置错误问题，可以通过img的load方法判断图片是否加载完成。<br>子组件：<div class="hljs"><pre><code class="hljs js">imgAllLoad() &#123;      <span class="hljs-keyword">const</span> mulitImg = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'.suggest-item-img'</span>)      <span class="hljs-keyword">const</span> promiseAll = []      <span class="hljs-keyword">const</span> imgTotal = mulitImg.length      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imgTotal; i++) &#123;        promiseAll[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;          mulitImg[i].onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-comment">// 第i张加载完成</span>            resolve(mulitImg[i])          &#125;        &#125;)      &#125;      <span class="hljs-keyword">return</span> promiseAll    &#125;,</code></pre></div>在子组件mounted中：派发一个imgLoad方法<div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.all(<span class="hljs-keyword">this</span>.imgAllLoad()).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'imgLoad'</span>)    &#125;)</code></pre></div>在父组件监听此方法，并刷新scroll组件<div class="hljs"><pre><code class="hljs js">methods: &#123;    imgLoad() &#123;      <span class="hljs-keyword">this</span>.$refs.scroll.refresh()    &#125;  &#125;,</code></pre></div>这样体验就不错了。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v-show和v-if的思考</title>
    <link href="/2020/11/29/v-show%E5%92%8Cv-if%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2020/11/29/v-show%E5%92%8Cv-if%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="v-show和v-if"><a href="#v-show和v-if" class="headerlink" title="v-show和v-if"></a>v-show和v-if</h2><p>今天在写一个项目时，遇到了一个问题。使用了better-scroll来做页面滚动，首页进入后可以滚动，但是点击搜索框后出现搜索记录却无法滚动。查看scroll的打印发现 <code>hasVerticalScroll: false</code>，并且scrollerHeight和clientHeight都是0，那就是都没有获得高度。最后把v-show改成v-if就可以了。</p><ul><li>问题出现原因：<br>众所周知，v-show渲染了dom，只是把dom的style设置为：display:none ，而使用了 display:none 的元素使用js是无法获得一些属性的值的,你可以通过  <code>console.dir(dom)</code> 获得dom的所有属性和方法，可以看到：</li><li>clientHeight: 0</li><li>clientLeft: 0</li><li>clientTop: 0</li><li>clientWidth: 0，</li><li>offsetHeight: 0</li><li>offsetLeft: 0</li><li>offsetTop: 0</li><li>offsetWidth: 0，</li><li>scrollHeight: 0</li><li>scrollLeft: 0</li><li>scrollTop: 0</li><li>scrollWidth: 0</li></ul><p>而 v-if 是会在条件满足时进行渲染的，所以能够直接获得 dom 属性值，可以计算 wrapper 和 content 的高度， 当 <code>wrapperHeight &lt; contentHeight</code> 时，就可以滚动了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js语法细节</title>
    <link href="/2020/11/21/js%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"/>
    <url>/2020/11/21/js%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><p>它们没有 this。在箭头函数内部访问到的 this 都是从外部获取的。</p><h2 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h2><ul><li>通常我们这样写<div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address</span>alert( user &amp;&amp; user.address &amp;&amp; user.address.street ); <span class="hljs-comment">// undefined（不报错）</span></code></pre></div>依次对整条路径上的属性使用与运算进行判断，以确保所有节点是存在的（如果不存在，则停止计算），但是写起来很麻烦。</li><li>通过可选链可以这样<div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;alert( user?.address ); <span class="hljs-comment">// undefined</span>alert( user?.address.street ); <span class="hljs-comment">// undefined</span></code></pre></div><blockquote><p>不要过度使用可选链</p></blockquote></li></ul><blockquote><p>我们应该只将 ?. 使用在一些东西可以不存在的地方。<br>例如，如果根据我们的代码逻辑，user 对象必须存在，但 address 是可选的，那么 user.address?.street 会更好。<br>所以，如果 user 恰巧因为失误变为 undefined，我们会看到一个编程错误并修复它。否则，代码中的错误在不恰当的地方被消除了，这会导致调试更加困难。</p></blockquote><div class="hljs"><pre><code class="hljs ?.()```检查左边是否存在，存在就执行,否则运算停止，不报错。">### 总结可选链 ?. 语法有三种形式：- obj?.prop —— 如果 obj 存在则返回 obj.prop，否则返回 undefined。- obj?.[prop] —— 如果 obj 存在则返回 obj[prop]，否则返回 undefined。- obj.method?.() —— 如果 obj.method 存在则调用 obj.method()，否则返回 undefined。&gt;正如我们所看到的，这些语法形式用起来都很简单直接。?. 检查左边部分是否为 null&#x2F;undefined，如果不是则继续运算。?. 链使我们能够安全地访问嵌套属性。&gt;但是，我们应该谨慎地使用 ?.，仅在当左边部分不存在也没问题的情况下使用为宜。以保证在代码中有编程上的错误出现时，也不会对我们隐藏。## Symbol如果我们要在对象字面量 &#123;...&#125; 中使用 Symbol，则需要使用方括号把它括起来。就像这样：&#96;&#96;&#96;jslet id &#x3D; Symbol(&quot;id&quot;);let user &#x3D; &#123;  name: &quot;John&quot;,  [id]: 123 &#x2F;&#x2F; 而不是 &quot;id&quot;：123&#125;;</code></pre></div><p>这是因为我们需要变量 id 的值作为键，而不是字符串 “id”。</p><blockquote><p>Symbol 属性不参与 for..in 循环。</p></blockquote><blockquote><p>Object.assign 会同时复制字符串和 symbol 属性</p></blockquote><blockquote><p>参考：<a href="https://zh.javascript.info/symbol#dui-xiang-zi-mian-liang-zhong-de-symbol" target="_blank" rel="noopener">symbol</a></p></blockquote><h2 id="对象原始值的转换"><a href="#对象原始值的转换" class="headerlink" title="对象原始值的转换"></a>对象原始值的转换</h2><p>如果没有 Symbol.toPrimitive，那么 JavaScript 将尝试找到它们，并且按照下面的顺序进行尝试：</p><ul><li>对于 “string” hint，toString -&gt; valueOf。</li><li>其他情况，valueOf -&gt; toString。</li></ul><p>默认情况下，普通对象具有 toString 和 valueOf 方法：</p><ul><li>toString 方法返回一个字符串 “[object Object]”。</li><li>valueOf 方法返回对象自身。</li><li>如果没有 Symbol.toPrimitive 和 valueOf，toString 将处理所有原始转换。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。</p><p>这里有三种类型（hint）：</p><ul><li>“string”（对于 alert 和其他需要字符串的操作）</li><li>“number”（对于数学运算）</li><li>“default”（少数运算符）<br>规范明确描述了哪个运算符使用哪个 hint。很少有运算符“不知道期望什么”并使用 “default” hint。通常对于内建对象，”default” hint 的处理方式与 “number” 相同，因此在实践中，最后两个 hint 常常合并在一起。</li></ul><p>转换算法是：</p><p>1.调用 obj<a href="hint">Symbol.toPrimitive</a> 如果这个方法存在，</p><p>2.否则，如果 hint 是 “string”</p><ul><li>尝试 obj.toString() 和 obj.valueOf()，无论哪个存在。</li></ul><p>3.否则，如果 hint 是 “number” 或者 “default”</p><ul><li>尝试 obj.valueOf() 和 obj.toString()，无论哪个存在。<br>在实践中，为了便于进行日志记录或调试，对于所有能够返回一种“可读性好”的对象的表达形式的转换，只实现以 obj.toString() 作为全能转换的方法就够了。</li></ul><blockquote><p>参考 <a href="https://zh.javascript.info/object-toprimitive#symboltoprimitive" target="_blank" rel="noopener">Symbol.toPrimitive</a></p></blockquote><h2 id="关于数组的length"><a href="#关于数组的length" class="headerlink" title="关于数组的length"></a>关于数组的length</h2><p>当我们修改数组的时候，length 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一。</p><p>例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 length 也会很大：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fruits = [];fruits[<span class="hljs-number">123</span>] = <span class="hljs-string">"Apple"</span>;alert( fruits.length ); <span class="hljs-comment">// 124</span></code></pre></div><p>要知道的是我们通常不会这样使用数组。</p><p>length 属性的另一个有意思的点是它是可写的。</p><p>如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的，下面是例子：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];arr.length = <span class="hljs-number">2</span>; <span class="hljs-comment">// 截断到只剩 2 个元素</span>alert( arr ); <span class="hljs-comment">// [1, 2]</span>arr.length = <span class="hljs-number">5</span>; <span class="hljs-comment">// 又把 length 加回来</span>alert( arr[<span class="hljs-number">3</span>] ); <span class="hljs-comment">// undefined：被截断的那些数值并没有回来</span></code></pre></div><blockquote><p>所以，清空数组最简单的方法就是：arr.length = 0;</p></blockquote><h2 id="关于JSON的转换"><a href="#关于JSON的转换" class="headerlink" title="关于JSON的转换"></a>关于JSON的转换</h2><p>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 JSON.stringify 跳过。</p><p>即：</p><ul><li>函数属性（方法）。</li><li>Symbol 类型的属性。</li><li>存储 undefined 的属性。</li></ul><h2 id="js中函数就是对象"><a href="#js中函数就是对象" class="headerlink" title="js中函数就是对象"></a>js中函数就是对象</h2><blockquote><p>被赋值给函数的属性，比如 sayHi.counter = 0，不会 在函数内定义一个局部变量 counter。换句话说，属性 counter 和变量 let counter 是毫不相关的两个东西。</p></blockquote><blockquote><p>我们可以把函数当作对象，在它里面存储属性，但是这对它的执行没有任何影响。变量不是函数属性，反之亦然。它们之间是平行的。</p></blockquote><h2 id="关于this和箭头函数"><a href="#关于this和箭头函数" class="headerlink" title="关于this和箭头函数"></a>关于this和箭头函数</h2><p>箭头函数</p><ul><li>没有 this</li><li>没有 arguments</li><li>不能使用 new 进行调用</li><li>它们也没有 super</li></ul><p>所以箭头函数里的 <code>this</code> 的查找与常规变量的搜索方式完全相同：在外部词法环境中查找。</p><h2 id="关于proto和prototype"><a href="#关于proto和prototype" class="headerlink" title="关于proto和prototype"></a>关于<strong>proto</strong>和prototype</h2><blockquote><p>初学者常犯一个普遍的错误，就是不知道 <code>__proto__</code> 和 [[Prototype]] 的区别。<br>请注意，<code>__proto__</code> 与内部的 [[Prototype]] 不一样。<code>__proto__</code> 是 [[Prototype]] 的 getter/setter。稍后，我们将看到在什么情况下理解它们很重要，在建立对 JavaScript 语言的理解时，让我们牢记这一点。</p></blockquote><div class="hljs"><pre><code class="hljs __proto__```">根据规范，&#96;&#96;&#96;__proto__&#96;&#96;&#96; 必须仅受浏览器环境的支持。但实际上，包括服务端在内的所有环境都支持它，因此我们使用它是非常安全的。重要：[this的值](https:&#x2F;&#x2F;zh.javascript.info&#x2F;prototype-inheritance#this-de-zhi)### 设置和直接访问原型的现代方法设置和直接访问原型的现代方法有：- Object.create(proto, [descriptors]) —— 利用给定的 proto 作为 [[Prototype]]（可以是 null）和可选的属性描述来创建一个空对象。- Object.getPrototypeOf(obj) —— 返回对象 obj 的 [[Prototype]]（与 &#96;&#96;&#96;__proto__&#96;&#96;&#96; 的 getter 相同）。- Object.setPrototypeOf(obj, proto) —— 将对象 obj 的 [[Prototype]] 设置为 proto（与 &#96;&#96;&#96;__proto__&#96;&#96;&#96; 的 setter 相同）。如果要将一个用户生成的键放入一个对象，那么内建的 &#96;&#96;&#96;__proto__&#96;&#96;&#96; getter&#x2F;setter 是不安全的。因为用户可能会输入 &quot;&#96;&#96;&#96;__proto__&#96;&#96;&#96;&quot; 作为键，这会导致一个 error，虽然我们希望这个问题不会造成什么大影响，但通常会造成不可预料的后果。因此，我们可以使用 Object.create(null) 创建一个没有 &#96;&#96;&#96;__proto__&#96;&#96;&#96; 的 “very plain” 对象，或者对此类场景坚持使用 Map 对象就可以了。此外，Object.create 提供了一种简单的方式来浅拷贝一个对象的所有描述符：&#96;&#96;&#96;jslet clone &#x3D; Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));</code></pre></div><p>此外，我们还明确了 <code>__proto__</code> 是 [[Prototype]] 的 getter/setter，就像其他方法一样，它位于 Object.prototype。</p><p>我们可以通过 Object.create(null) 来创建没有原型的对象。这样的对象被用作 “pure dictionaries”，对于它们而言，使用 “<code>__proto__</code>“ 作为键是没有问题的。</p><p>其他方法：</p><ul><li>Object.keys(obj) / Object.values(obj) / Object.entries(obj) —— 返回一个可枚举的由自身的字符串属性名/值/键值对组成的数组。</li><li>Object.getOwnPropertySymbols(obj) —— 返回一个由自身所有的 symbol 类型的键组成的数组。</li><li>Object.getOwnPropertyNames(obj) —— 返回一个由自身所有的字符串键组成的数组。</li><li>Reflect.ownKeys(obj) —— 返回一个由自身所有键组成的数组。</li><li>obj.hasOwnProperty(key)：如果 obj 拥有名为 key 的自身的属性（非继承而来的），则返回 true。</li></ul><p>所有返回对象属性的方法（如Object.keys 及其他）—— 都返回“自身”的属性。如果我们想继承它们，我们可以使用 for…in。</p><h2 id="关于类继承"><a href="#关于类继承" class="headerlink" title="关于类继承"></a>关于类继承</h2><p>1.想要扩展一个类：class Child extends Parent：</p><ul><li>这意味着 Child.prototype.<strong>proto</strong> 将是 Parent.prototype，所以方法会被继承。</li></ul><p>2.重写一个 constructor：</p><ul><li>在使用 this 之前，我们必须在 Child 的 constructor 中将父 constructor 调用为 super()。</li></ul><p>3.重写一个方法：</p><ul><li>我们可以在一个 Child 方法中使用 super.method() 来调用 Parent 方法。</li></ul><p>4.内部：</p><ul><li>方法在内部的 [[HomeObject]] 属性中记住了它们的类/对象。这就是 super 如何解析父方法的。</li><li>因此，将一个带有 super 的方法从一个对象复制到另一个对象是不安全的。</li></ul><p>补充：</p><p>箭头函数没有自己的 this 或 super，所以它们能融入到就近的上下文中，像透明似的。</p><h2 id="类检查”instanceof”"><a href="#类检查”instanceof”" class="headerlink" title="类检查”instanceof”"></a>类检查”instanceof”</h2><table><thead><tr><th></th><th>用于</th><th>返回值</th></tr></thead><tbody><tr><td>type</td><td>原始数据类型</td><td>string</td></tr><tr><td>{}.toString.call</td><td>原始数据类型，内建对象，包含Symbol.toStringTag属性的对象</td><td>string</td></tr><tr><td>instanceof</td><td>对象</td><td>true/false</td></tr></tbody></table><p>如表所示：{}.toString.call (Object.prototype.toString) 可以检查对象的类型并返回字符串，而不是像toString仅仅返回 <code>[Object,Object]</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">Object</span>.prototype.toString;alert( s.call(<span class="hljs-number">123</span>) ); <span class="hljs-comment">// [object Number]</span>alert( s.call(<span class="hljs-literal">null</span>) ); <span class="hljs-comment">// [object Null]</span>alert( s.call(alert) ); <span class="hljs-comment">// [object Function]</span></code></pre></div><h2 id="模块的导入和导出"><a href="#模块的导入和导出" class="headerlink" title="模块的导入和导出"></a>模块的导入和导出</h2><ul><li>在声明一个 class/function/… 之前：<ul><li>export [default] class/function/variable …</li></ul></li><li>独立的导出：<ul><li>export {x [as y], …}.</li></ul></li><li>重新导出：<ul><li>export {x [as y], …} from “module”</li><li>export * from “module”（不会重新导出默认的导出）。</li><li>export {default [as y]} from “module”（重新导出默认的导出）。</li></ul></li></ul><p>导入：</p><ul><li>模块中命名的导入：<ul><li>import {x [as y], …} from “module”</li></ul></li><li>默认的导入：<ul><li>import x from “module”</li><li>import {default as x} from “module”</li></ul></li><li>所有：<ul><li>import * as obj from “module”</li></ul></li><li>导入模块（它的代码，并运行），但不要将其赋值给变量：<ul><li>import “module”</li></ul></li></ul><p>我们把 import/export 语句放在脚本的顶部或底部，都没关系。</p><h2 id="处理程序选项-“passive”"><a href="#处理程序选项-“passive”" class="headerlink" title="处理程序选项 “passive”"></a>处理程序选项 “passive”</h2><p>addEventListener 的可选项 passive: true 向浏览器发出信号，表明处理程序将不会调用 preventDefault()。</p><p>为什么需要这样做？</p><p>移动设备上会发生一些事件，例如 touchmove（当用户在屏幕上移动手指时），默认情况下会导致滚动，但是可以使用处理程序的 preventDefault() 来阻止滚动。</p><p>因此，当浏览器检测到此类事件时，它必须首先处理所有处理程序，然后如果没有任何地方调用 preventDefault，则页面可以继续滚动。但这可能会导致 UI 中不必要的延迟和“抖动”。</p><p>passive: true 选项告诉浏览器，处理程序不会取消滚动。然后浏览器立即滚动页面以提供最大程度的流畅体验，并通过某种方式处理事件。</p><p>对于某些浏览器（Firefox，Chrome），默认情况下，touchstart 和 touchmove 事件的 passive 为 true。</p><h2 id="async和defer"><a href="#async和defer" class="headerlink" title="async和defer"></a>async和defer</h2><table><thead><tr><th></th><th>顺序</th><th>DOMContentLoaded</th></tr></thead><tbody><tr><td>async</td><td>加载优先顺序。脚本在文档中的顺序不重要 —— 先加载完成的先执行</td><td>不相关。可能在文档加载完成前加载并执行完毕。如果脚本很小或者来自于缓存，同时文档足够长，就会发生这种情况。</td></tr><tr><td>defer</td><td>文档顺序（它们在文档中的顺序）</td><td>在文档加载和解析完成之后（如果需要，则会等待），即在 DOMContentLoaded 之前执行。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中的.passive修饰符</title>
    <link href="/2020/11/07/vue%E4%B8%AD%E7%9A%84-passive%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2020/11/07/vue%E4%B8%AD%E7%9A%84-passive%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="vue中的-passive-修饰符"><a href="#vue中的-passive-修饰符" class="headerlink" title="vue中的 .passive 修饰符"></a>vue中的 .passive 修饰符</h2><p>Vue提供了事件绑定的语法糖，我们在标签中可直接使用形如v-on:click，@click，@focus的形式绑定事件监听器，并且可以使用修饰符对事件进行option设置。本次解释下prevent 与passive的修饰符。prevent 是拦截默认事件，passive是不拦截默认事件。</p><h3 id="prevent"><a href="#prevent" class="headerlink" title="prevent"></a>prevent</h3><p>某些标签拥有自身的默认事件，如a[href=”#”]，button[type=”submit”] 这种标签在冒泡结束后会开始执行默认事件。注意默认事件虽然是冒泡后开始，但不会因为stop阻止事件传递而停止。</p><h3 id="passive"><a href="#passive" class="headerlink" title="passive"></a>passive</h3><p>passive这个修饰符会执行默认方法。你们可能会问，明明默认执行为什么会设置这样一个修饰符。这就要说一下这个修饰符的本意了。</p><p>【浏览器只有等内核线程执行到事件监听器对应的JavaScript代码时，才能知道内部是否会调用preventDefault函数来阻止事件的默认行为，所以浏览器本身是没有办法对这种场景进行优化的。这种场景下，用户的手势事件无法快速产生，会导致页面无法快速执行滑动逻辑，从而让用户感觉到页面卡顿。】</p><p>通俗点说就是每次事件产生，浏览器都会去查询一下是否有preventDefault阻止该次事件的默认动作。我们加上passive就是为了告诉浏览器，不用查询了，我们没用preventDefault阻止默认动作。</p><p><font color="#1ABC9C">这里一般用在滚动监听，@scoll，@touchmove 。因为滚动监听过程中，移动每个像素都会产生一次事件，每次都使用内核线程查询prevent会使滑动卡顿。我们通过passive将内核线程查询跳过，可以大大提升滑动的流畅度。</font></p><p>注：passive和prevent冲突，不能同时绑定在一个监听器上。</p><p>参考：<a href="https://www.jianshu.com/p/b12d0d3ad4c1" target="_blank" rel="noopener">vue中的 .passive 修饰符</a></p>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的双向数据绑定</title>
    <link href="/2020/11/06/vue%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <url>/2020/11/06/vue%E7%9A%84%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="vue的双向数据绑定"><a href="#vue的双向数据绑定" class="headerlink" title="vue的双向数据绑定"></a>vue的双向数据绑定</h2><p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。原理图：<br><img src="/img/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/reactive.jpg" srcset="/img/loading.gif" alt="vue的双向数据绑定"></p><p>通过 Object.defineProperty() 方法劫持 对象的 getter、setter方法，在通过发布订阅模式完成 data –&gt; 视图 和 视图 –&gt; data 的双向更新。<br>具体查看: <a href="https://www.cnblogs.com/canfoo/p/6891868.html" target="_blank" rel="noopener">vue的双向绑定</a></p>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo部署时出现excepted token解决方法</title>
    <link href="/2020/11/06/token%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2020/11/06/token%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo部署时出现json解析错误"><a href="#hexo部署时出现json解析错误" class="headerlink" title="hexo部署时出现json解析错误"></a>hexo部署时出现json解析错误</h2><p>部署时出现 excepted token x in position，很奇怪，找到源代码有一句<code>json.parse</code>,打印了一下发现是某个json对象传入了json.parse。但是这个json对象还必须要有。最后想到了skip_render，发现已经配置了，但是还是渲染的了那些文件。</p><div class="hljs"><pre><code class="hljs plain">skip_render:  - &quot;somedir&#x2F;*&quot;</code></pre></div><p>最后去github hexo的 issue 里找到了一个这个：</p><div class="hljs"><pre><code class="hljs plain">- &quot;somedir&#x2F;**&#x2F;*&quot;</code></pre></div><p>怀疑是不是需要两个 ** ，尝试了一下，成功了。</p>]]></content>
    
    
    <categories>
      
      <category>错误</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的生命周期钩子updated</title>
    <link href="/2020/11/03/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90updated/"/>
    <url>/2020/11/03/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90updated/</url>
    
    <content type="html"><![CDATA[<h2 id="生命周期详细表"><a href="#生命周期详细表" class="headerlink" title="生命周期详细表"></a>生命周期详细表</h2><table><thead><tr><th>生命周期</th><th>详细</th></tr></thead><tbody><tr><td>beforeCreate</td><td>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用</td></tr><tr><td>created</td><td>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用。</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</td></tr><tr><td>beforeUpdate</td><td>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</td></tr><tr><td>updated</td><td>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</td></tr><tr><td>activated</td><td>keep-alive 组件激活时调用。</td></tr><tr><td>deactivated</td><td>keep-alive 组件停用时调用。</td></tr><tr><td>beforeDestroy</td><td>实例销毁之前调用。在这一步，实例仍然完全可用。</td></tr><tr><td>destroyed</td><td>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</td></tr><tr><td>备注</td><td>（除了beforeCreate和created钩子之外，其他钩子均在服务器端渲染期间不被调用。）<font color="#1ABC9C">只有updated钩子被调用时候，组件dom才被更新。</font></td></tr></tbody></table><p>可以在updated生命周期内更新页面部分dom，比如样式修改，阅读进度的样式显示。</p><ul><li>参考： <a href="https://www.cnblogs.com/goloving/p/8616989.html" target="_blank" rel="noopener">Vue生命周期</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于vue的mixin</title>
    <link href="/2020/10/30/%E5%85%B3%E4%BA%8Evue%E7%9A%84mixin/"/>
    <url>/2020/10/30/%E5%85%B3%E4%BA%8Evue%E7%9A%84mixin/</url>
    
    <content type="html"><![CDATA[<h2 id="vue的mixin"><a href="#vue的mixin" class="headerlink" title="vue的mixin"></a>vue的mixin</h2><p>当有多个组件写了多个同样的语句时，可以使用vue的mixin机制<br>创建一个utils/mixin.js文件，内容如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;  mapGetters,  mapActions&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bookMixin = &#123;  computed: &#123;    ...mapGetters([<span class="hljs-string">'bookName'</span>, <span class="hljs-string">'bookCover'</span>]),  &#125;,  methods: &#123;    ...mapActions([<span class="hljs-string">'setBookName'</span>, <span class="hljs-string">'setBookCover'</span>])  &#125;&#125;</code></pre></div><p>接下来就可以在组件内这样写：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; bookMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'utils/mixin'</span>  mixins:[bookMixin]  methods: &#123;&#125;</code></pre></div><p>这样可以将vuex的内容在一处增加，多处复用。</p><p>mapActions是写到methods里的，这样就可以替换这种写法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 原来写法</span><span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">'setBookName'</span>,<span class="hljs-keyword">this</span>.bookName)<span class="hljs-comment">// 优雅写法</span><span class="hljs-keyword">this</span>.setBookName(<span class="hljs-keyword">this</span>.bookName)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Echarts数据更新图表不更新解决方法思考</title>
    <link href="/2020/10/26/Echarts%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%9B%BE%E8%A1%A8%E4%B8%8D%E6%9B%B4%E6%96%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%80%9D%E8%80%83/"/>
    <url>/2020/10/26/Echarts%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%9B%BE%E8%A1%A8%E4%B8%8D%E6%9B%B4%E6%96%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="echart数据更新问题"><a href="#echart数据更新问题" class="headerlink" title="echart数据更新问题"></a>echart数据更新问题</h2><p>在使用vue-echarts组件时，通过watch监听option变化更新数据，用vue调试工具查看数据更新了，series数组内容改变了。<br>但是echart的线表有部分数据是上次的，有部分是最新的。百思不得其解。<br>最后突然想到vue的组件会复用，没有变化的不更新。最后通过强制更新图表插件解决问题。</p><p>这里记录一下四种更新数据的方法</p><h3 id="刷新整个页面（最low的，可以借助route机制）"><a href="#刷新整个页面（最low的，可以借助route机制）" class="headerlink" title="刷新整个页面（最low的，可以借助route机制）"></a>刷新整个页面（最low的，可以借助route机制）</h3><h3 id="使用v-if标记（比较low的）"><a href="#使用v-if标记（比较low的）" class="headerlink" title="使用v-if标记（比较low的）"></a>使用v-if标记（比较low的）</h3><h3 id="使用内置的forceUpdate方法（较好的）"><a href="#使用内置的forceUpdate方法（较好的）" class="headerlink" title="使用内置的forceUpdate方法（较好的）"></a>使用内置的forceUpdate方法（较好的）</h3><p>组件内置$forceUpdate方法，使用前需要在配置中启用。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>Vue.forceUpdate()<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  methods: &#123;    handleUpdateClick() &#123;      <span class="hljs-comment">// built-in</span>      <span class="hljs-keyword">this</span>.$forceUpdate()    &#125;  &#125;&#125;</code></pre></div><h3 id="使用key-changing优化组件（最好的"><a href="#使用key-changing优化组件（最好的" class="headerlink" title="使用key-changing优化组件（最好的)"></a>使用key-changing优化组件（最好的)</h3><p>原理很简单，vue使用key标记组件身份，当key改变时就是释放原始组件，重新加载新的组件。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"key"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span>        key: 0      &#125;    &#125;,    methods: &#123;      handleUpdateClick() &#123;<span class="actionscript">        <span class="hljs-keyword">this</span>.key += <span class="hljs-number">1</span></span>      &#125;    &#125;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些Vue小技巧</title>
    <link href="/2020/10/19/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/10/19/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="关于-vue-filters"><a href="#关于-vue-filters" class="headerlink" title="关于 vue.filters"></a>关于 vue.filters</h2><p>可以写在单个组件内，也可以单独写全局的然后加到 main.js 中，像是日期格式，数字格式就可以写在全局</p><h2 id="和！！"><a href="#和！！" class="headerlink" title="~~和！！"></a>~~和！！</h2><p>&#126;是按位取反运算，&#126;&#126;是取反两次。<br>&#126;&#126;的作用是去掉小数部分，因为位运算的操作值要求是整数，其结果也是整数，所以经过位运算的都会自动变成整数。<br>！一个！是取反，！！两个再取反，就是强制转换成 Boolen 类型</p><h2 id="关于-markdown-语法"><a href="#关于-markdown-语法" class="headerlink" title="关于 markdown 语法"></a>关于 markdown 语法</h2><p>如果要使用 Markdown 保留字，可以使用 Unicode 字符。如上面的&#126;&#126;,两边加&#126;&#126;会导致形成文字之间产生删除线，把&#126;&#126;换成<code>&amp;#126;&amp;#126;</code>就可以了。<a href="http://tool.oschina.net/encode" target="_blank" rel="noopener">Unicode 在线转义</a></p><h2 id="js-和-css-两用样式"><a href="#js-和-css-两用样式" class="headerlink" title="js 和 css 两用样式"></a>js 和 css 两用样式</h2><p>template 中需要动态定义样式，通常做法：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"&#123; color: textColor &#125;"</span>&gt;</span>Text<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">        textColor: <span class="hljs-string">"#ff5000"</span>,</span>      &#125;    &#125;,  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>高端做法：</p><ul><li>定义 scss 文件</li></ul><div class="hljs"><pre><code class="hljs scss"><span class="hljs-variable">$menuActiveText</span>: <span class="hljs-number">#409eff</span>;:export &#123;  menuActiveText: <span class="hljs-variable">$menuActiveText</span>;&#125;</code></pre></div><ul><li>在 js 中引用：<ul><li>使用 import 引用 scss 文件</li><li>定义 computed 将 styles 对象变成响应式对象</li><li>在 template 中使用 styles 对象</li></ul></li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"&#123; color: styles.menuActiveText &#125;"</span>&gt;</span>Text<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">"@/styles/variables.scss"</span></span><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    computed: &#123;      styles() &#123;<span class="actionscript">        <span class="hljs-keyword">return</span> styles</span>      &#125;,    &#125;,  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h2 id="连续解构"><a href="#连续解构" class="headerlink" title="连续解构"></a>连续解构</h2><p>从数组第一个对象元素中提取某个属性，比如：err 对象中包含一个 errors 数组，errors 数组每一个对象都包含一个 msg 属性</p><div class="hljs"><pre><code class="hljs js">err = &#123;  errors: [    &#123;      msg: <span class="hljs-string">"this is a message"</span>,    &#125;,  ],&#125;</code></pre></div><p>快速的提取方法为：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [&#123; msg &#125;] = err.errors</code></pre></div><p>如果不用解构写法为：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> msg = err.errors[<span class="hljs-number">0</span>].msg</code></pre></div><p>真不错！</p><h2 id="vm-nextTick"><a href="#vm-nextTick" class="headerlink" title="vm.$nextTick"></a>vm.$nextTick</h2><p>vue 更新 DOM 是异步的，如果你想基于更新后的 DOM 状态来做点什么，为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。详情参见:<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97" target="_blank" rel="noopener">异步更新队列</a></p><h2 id="columns-分页"><a href="#columns-分页" class="headerlink" title="columns 分页"></a>columns 分页</h2><p>利用 columns 实现小说分页效果，每一列的高度与父元素相同</p><h2 id="绝对定位居中"><a href="#绝对定位居中" class="headerlink" title="绝对定位居中"></a>绝对定位居中</h2><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>: auto;&#125;</code></pre></div><h2 id="使页面的左右边距相同"><a href="#使页面的左右边距相同" class="headerlink" title="使页面的左右边距相同"></a>使页面的左右边距相同</h2><p>可以父元素加 padding：15px, 子元素加 margin：15px， 这样所有间隙都是 30px。</p><h2 id="math-floor-和-0"><a href="#math-floor-和-0" class="headerlink" title="math.floor 和 | 0"></a>math.floor 和 <code>| 0</code></h2><div class="hljs"><pre><code class="hljs js">;(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">10</span> / <span class="hljs-number">3</span>) === <span class="hljs-number">10</span> / <span class="hljs-number">3</span>) | <span class="hljs-number">0</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>module的语法</title>
    <link href="/2020/09/28/module%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/09/28/module%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="module的语法"><a href="#module的语法" class="headerlink" title="module的语法"></a>module的语法</h2><p>export 规定的是对外的接口，必须与模块内部变量建立一一对应关系</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><span class="hljs-keyword">export</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 报错</span><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<span class="hljs-keyword">export</span> m;</code></pre></div><p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<span class="hljs-comment">// 写法二</span><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<span class="hljs-keyword">export</span> &#123;m&#125;;<span class="hljs-comment">// 写法三</span><span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<span class="hljs-keyword">export</span> &#123;n <span class="hljs-keyword">as</span> m&#125;;</code></pre></div><p>上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p><h2 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h2><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一组</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crc32</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 输出</span>  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">import</span> crc32 <span class="hljs-keyword">from</span> <span class="hljs-string">'crc32'</span>; <span class="hljs-comment">// 输入</span><span class="hljs-comment">// 第二组</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crc32</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 输出</span>  <span class="hljs-comment">// ...</span>&#125;;<span class="hljs-keyword">import</span> &#123;crc32&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'crc32'</span>; <span class="hljs-comment">// 输入</span></code></pre></div><p>上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。</p><p>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。</p><p>本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// modules.js</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-keyword">return</span> x * y;&#125;<span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;<span class="hljs-comment">// 等同于</span><span class="hljs-comment">// export default add;</span><span class="hljs-comment">// app.js</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'modules'</span>;<span class="hljs-comment">// 等同于</span><span class="hljs-comment">// import foo from 'modules';</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件使用中的小细节</title>
    <link href="/2020/09/24/%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/09/24/%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="is的使用"><a href="#is的使用" class="headerlink" title="is的使用"></a>is的使用</h2><p>当使用表格时，只能在tbody中添加td，可以使用is=’模板名称’</p><h2 id="data的定义"><a href="#data的定义" class="headerlink" title="data的定义"></a>data的定义</h2><p>在根组件中可以用对象，子组件中data只能是一个方法</p><h2 id="ref方法"><a href="#ref方法" class="headerlink" title="ref方法"></a>ref方法</h2><p>可以获取ref的DOM结构，和ref组件中的数据</p><h2 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h2><p>父组件可以向子组件传递任何数据，但子组件不能直接修改父组件的值（单向数据流）,当不写v-bind时，传递的就是一个字符串，写了:或者v-bind后就是一个javascript表达式了。</p><h2 id="组件参数校验"><a href="#组件参数校验" class="headerlink" title="组件参数校验"></a>组件参数校验</h2><h2 id="给组件绑定原生事件"><a href="#给组件绑定原生事件" class="headerlink" title="给组件绑定原生事件"></a>给组件绑定原生事件</h2><p>.native 不需要子组件向外$emit,只需在父组件中写处理方法。子组件上绑定的就是原生的click方法，而不是自定义的方法。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">child</span> @<span class="hljs-attr">click.native</span>=<span class="hljs-string">"handleClick"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h2 id="非父子组件传值-Bus-总线-发布订阅模式-观察者模式"><a href="#非父子组件传值-Bus-总线-发布订阅模式-观察者模式" class="headerlink" title="非父子组件传值(Bus/总线/发布订阅模式/观察者模式)"></a>非父子组件传值(Bus/总线/发布订阅模式/观察者模式)</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">content</span>=<span class="hljs-string">'123'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">content</span>=<span class="hljs-string">'456'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  Vue.prototype.bus = <span class="hljs-keyword">new</span> Vue()</span><span class="actionscript">  Vue.component(<span class="hljs-string">'child'</span>,&#123;</span>    props: &#123;<span class="javascript">      content:<span class="hljs-built_in">String</span></span>    &#125;,    data () &#123;<span class="actionscript">      <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">        childContent:<span class="hljs-keyword">this</span>.content</span>      &#125;    &#125;,<span class="handlebars"><span class="xml">    template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleClick"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;childContent&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>',</span></span>    methods:&#123;      handleClick() &#123;<span class="actionscript">        <span class="hljs-keyword">this</span>.bus.$emit(<span class="hljs-string">'change'</span>,<span class="hljs-keyword">this</span>.childContent)</span>      &#125;    &#125;,    mounted() &#123;<span class="javascript">      <span class="hljs-keyword">let</span> this_ = <span class="hljs-keyword">this</span></span><span class="actionscript">      <span class="hljs-keyword">this</span>.bus.$on(<span class="hljs-string">'change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(msg)</span></span>&#123;</span><span class="actionscript">        this_.childContent = msg <span class="hljs-comment">//外部this指向vue的实例，内部this指向bus的实例</span></span>      &#125;)    &#125;  &#125;)<span class="actionscript">  <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">    el:<span class="hljs-string">'#app'</span></span>  &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h2 id="插槽-amp-具名插槽"><a href="#插槽-amp-具名插槽" class="headerlink" title="插槽&amp;具名插槽"></a>插槽&amp;具名插槽</h2><p>父组件通过插槽向子组件传递DOM元素</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"header"</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  Vue.component('child',&#123;    tempalte:`<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"header"</span>&gt;</span>默认内容<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`  &#125;)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中v-if</title>
    <link href="/2020/09/24/vue%E4%B8%AD%E7%BB%86%E8%8A%82%E7%82%B9/"/>
    <url>/2020/09/24/vue%E4%B8%AD%E7%BB%86%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>当在input框中使用v-if时，如果输入了字符后，改变v-if的显示时，input中的内容不会变化，这是因为vue会尽量复用页面的内容，增加渲染效率，这时可以为每个input增加一个key值，这样vue发现key值不同便不会复用了。</p><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>使用v-for时，如果不想在外层添加一个div标签，可以使用template作为模版占位符，这个不会在页面中渲染。</p><h2 id="set"><a href="#set" class="headerlink" title="$set"></a>$set</h2><p>向对象增加属性值时，一种方法是整个改变对象的引用，另一种是通过vue实例.$set(对象，新属性名，新属性值)，这样才能实时更新数据。Vue.set()或vue实例.$set()。<br>向数组改变数据时，一：通过vue提供的7个变异方法，二：通过改变数组引用，三：通过vue实例.$set(数组，愿属性的index，新属性)。</p><h2 id="click事件修饰符"><a href="#click事件修饰符" class="headerlink" title="click事件修饰符"></a>click事件修饰符</h2><p>.prevent阻止默认行为<br>.stop阻止向上冒泡<br>.self只有点击自身才触发时间，冒泡的不行，click事件只有e.target = e.currentTaget时才会执行<br>.once 只绑定一次，只能触发一次<br>.capture 事件捕获规则，从外部向内部触发，不是事件冒泡了</p><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>.enter …</p><h2 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h2><p>.ctrl …</p><h2 id="鼠标修饰符"><a href="#鼠标修饰符" class="headerlink" title="鼠标修饰符"></a>鼠标修饰符</h2><p>.right 右键</p><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p>过渡的元素只能是以下之一：</p><ul><li>条件渲染 (使用 v-if)</li><li>条件展示 (使用 v-show)</li><li>动态组件</li><li>组件根节点</li></ul><p>自定义过渡动画的，记得在css中修改以下的类名：</p><ul><li>动画名-enter 进入前效果</li><li>动画名-enter-active 进入的过渡时间和函数</li><li>动画名-enter-to 进入后效果</li><li>动画名-leave 离开前效果</li><li>动画名-leave-active 离开的过渡时间和函数</li><li>动画名-leave-to 离开后效果</li></ul><h2 id="vue中-exact效果"><a href="#vue中-exact效果" class="headerlink" title="vue中.exact效果"></a>vue中.exact效果</h2><p>只能是绑定的键才能触发方法，多按shift或者ctrl无法触发</p><h2 id="两个连续动画的展示"><a href="#两个连续动画的展示" class="headerlink" title="两个连续动画的展示"></a>两个连续动画的展示</h2><ul><li><p>问题：当有两个连续性的动画需要显示时，比如先显示透明的蒙版，再显示滑出动画。如果仅仅将两个v-if置为true，第二个动画不会显示出效果，因为两个动画同时被置为true时，同时运动 transition time，所以只会看到动画结束后最后的效果。</p></li><li><p>解决：要同时看到两个连续的动画，需把后一个动画设置到setTimeout里，可以不设置延迟时间或者设置一个很小的延迟时间，作为一个微任务来处理。</p></li></ul><h2 id="阻止点击事件"><a href="#阻止点击事件" class="headerlink" title="阻止点击事件"></a>阻止点击事件</h2><p>@click.prevent  阻止默认事件<br>@click.stop  阻止冒泡</p><h2 id="vue中created用处"><a href="#vue中created用处" class="headerlink" title="vue中created用处"></a>vue中created用处</h2><ul><li>1.可以在这里请求数据</li><li>2.当有些数据没必要放入data中监听，但是methods中的方法有需要共用时，可以放在created中，vue不会设置setter和getter。</li></ul>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>slice的思考</title>
    <link href="/2020/08/23/slice%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2020/08/23/slice%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="关于为何在函数中使用Array-prototype-slice-call而不是直接用slice？"><a href="#关于为何在函数中使用Array-prototype-slice-call而不是直接用slice？" class="headerlink" title="关于为何在函数中使用Array.prototype.slice.call而不是直接用slice？"></a>关于为何在函数中使用Array.prototype.slice.call而不是直接用slice？</h2><p>经常会看到这种写法，在一个函数中使用，Array.prototype.slice.call(arguments,1); 除了防止传入的arguments有slice同名函数，还有其他什么用处吗？</p><p>尤大的回答：</p><blockquote><p>arguments是每个函数在运行的时候自动获得的一个近似数组的对象（传入函数的参数从0开始按数字排列，而且有length）。比如当你 func(‘a’, ‘b’, ‘c’) 的时候，func里面获得的arguments[0] 是 ‘a’，arguments[1] 是 ‘b’，依次类推。但问题在于这个arguments对象其实并不是Array，所以没有slice方法。Array.prototype.slice.call( )可以间接对其实现slice的效果，而且返回的结果是真正的Array。</p></blockquote><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>写箭头函数时，如果箭头函数后面加了<code>{}</code>，里面代表代码块，必须写<code>return</code>,如果不写<code>{}</code>,就是直接返回，不用写<code>return</code>。</p><h2 id="函数的形参实参"><a href="#函数的形参实参" class="headerlink" title="函数的形参实参"></a>函数的形参实参</h2><p>函数的形参几个用 <code>fn.length</code> 获得,函数的实参用<code>arguments.length</code>获得。</p><h2 id="自执行函数与惰性函数"><a href="#自执行函数与惰性函数" class="headerlink" title="自执行函数与惰性函数"></a>自执行函数与惰性函数</h2><p>自执行函数就是惰性函数，自执行函数可以分割函数作用域。<br>惰性函数表示函数执行的分支只会在函数第一次调用的时候执行。后续我们所使用的就是这个函数执行的结果。</p>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>express三大概念</title>
    <link href="/2020/07/17/express%E4%B8%89%E5%A4%A7%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/07/17/express%E4%B8%89%E5%A4%A7%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="Express-三大基础概念"><a href="#Express-三大基础概念" class="headerlink" title="Express 三大基础概念"></a>Express 三大基础概念</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件是一个函数，在请求和响应周期中被顺序调用</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myLogger = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'myLogger'</span>)  next()&#125;app.use(myLogger)</code></pre></div><p>提示：中间件需要在响应结束前被调用</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>应用如何响应请求的一种规则<br>响应 / 路径的 get 请求：</p><div class="hljs"><pre><code class="hljs javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;  res.send(<span class="hljs-string">'hello node'</span>)&#125;)</code></pre></div><p>响应 / 路径的 post 请求：</p><div class="hljs"><pre><code class="hljs javascript">app.post(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;  res.send(<span class="hljs-string">'hello node'</span>)&#125;)</code></pre></div><p>规则主要分两部分：</p><ul><li>请求方法：get、post……</li><li>请求的路径：/、/user、/.*fly$/……</li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>通过自定义异常处理中间件处理请求中产生的异常</p><div class="hljs"><pre><code class="hljs javascript">app.get(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'something has error...'</span>)&#125;)<span class="hljs-keyword">const</span> errorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, req, res, next</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'errorHandler...'</span>)  res.status(<span class="hljs-number">500</span>).json(&#123;    error:<span class="hljs-string">'Error...'</span>  &#125;)&#125;app.use(errorHandler)</code></pre></div><p>使用时需要注意两点：</p><ul><li>第一，参数一个不能少，否则会视为普通的中间件</li><li>第二，中间件需要在请求之后引用</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>express</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>class和style绑定,vue.observable,slot插槽</title>
    <link href="/2020/07/14/class%E5%92%8Cstyle%E7%BB%91%E5%AE%9A/"/>
    <url>/2020/07/14/class%E5%92%8Cstyle%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="class和style绑定"><a href="#class和style绑定" class="headerlink" title="class和style绑定"></a>class和style绑定</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>class 和 style 绑定的高级用法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"['active', 'normal']"</span>&gt;</span>数组绑定多个class<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"[&#123;active: isActive&#125;, 'normal']"</span>&gt;</span>数组包含对象绑定class<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"[showWarning(), 'normal']"</span>&gt;</span>数组包含方法绑定class<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"[warning, bold]"</span>&gt;</span>数组绑定多个style<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"[warning, mix()]"</span>&gt;</span>数组包含方法绑定style<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"</span>&gt;</span>style多重值<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root'</span>,</span>        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            isActive: <span class="hljs-literal">true</span>,</span>            warning: &#123;<span class="actionscript">              color: <span class="hljs-string">'orange'</span></span>            &#125;,            bold: &#123;<span class="actionscript">              fontWeight: <span class="hljs-string">'bold'</span></span>            &#125;          &#125;        &#125;,        methods: &#123;          showWarning() &#123;<span class="actionscript">            <span class="hljs-keyword">return</span> <span class="hljs-string">'warning'</span></span>          &#125;,          mix() &#123;<span class="actionscript">            <span class="hljs-keyword">return</span> &#123;</span>              ...this.bold,              fontSize: 20            &#125;          &#125;        &#125;      &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="vue-observable"><a href="#vue-observable" class="headerlink" title="vue.observable"></a>vue.observable</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue.observable<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>      &#123;&#123;message&#125;&#125;      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"change"</span>&gt;</span>Change<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">      <span class="hljs-keyword">const</span> state = Vue.observable(&#123; message: <span class="hljs-string">'Vue 2.6'</span> &#125;)</span><span class="actionscript">      <span class="hljs-keyword">const</span> mutation = &#123;</span>        setMessage(value) &#123;          state.message = value        &#125;      &#125;<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root'</span>,</span>        computed: &#123;          message() &#123;<span class="actionscript">            <span class="hljs-keyword">return</span> state.message</span>          &#125;        &#125;,        methods: &#123;          change() &#123;<span class="actionscript">            mutation.setMessage(<span class="hljs-string">'Vue 3.0'</span>)</span>          &#125;        &#125;      &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>插槽 slot<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>案例1：slot的基本用法<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">Test</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>=<span class="hljs-string">"&#123;user&#125;"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>自定义header(&#123;&#123;user.a&#125;&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"&#123;user&#125;"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>自定义body(&#123;&#123;user.b&#125;&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">Test</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root2"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>案例2：Vue2.6新特性 - 动态slot<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">Test</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">section</span>]=<span class="hljs-string">"&#123;section&#125;"</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>this is &#123;&#123;section&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">Test</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"change"</span>&gt;</span>switch header and body<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">      Vue.component(<span class="hljs-string">'Test'</span>, &#123;</span>        template:<span class="actionscript">          <span class="hljs-string">'&lt;div&gt;'</span> +</span><span class="handlebars"><span class="xml">            '<span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"header"</span> <span class="hljs-attr">:user</span>=<span class="hljs-string">"obj"</span> <span class="hljs-attr">:section</span>=<span class="hljs-string">"\'header\'"</span>&gt;</span>' +</span></span><span class="handlebars"><span class="xml">              '<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>默认header<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>' +</span></span><span class="actionscript">            <span class="hljs-string">'&lt;/slot&gt;'</span> +</span><span class="handlebars"><span class="xml">            '<span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:user</span>=<span class="hljs-string">"obj"</span> <span class="hljs-attr">:section</span>=<span class="hljs-string">"\'body\'"</span>&gt;</span>默认body<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>' +</span></span><span class="actionscript">          <span class="hljs-string">'&lt;/div&gt;'</span>,</span>        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span>            obj: &#123; a: 1, b: 2 &#125;          &#125;        &#125;      &#125;)<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123; el: <span class="hljs-string">'#root'</span> &#125;)</span><span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root2'</span>,</span>        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            section: <span class="hljs-string">'header'</span></span>          &#125;        &#125;,        methods: &#123;          change() &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.section === <span class="hljs-string">'header'</span> ?</span><span class="actionscript">              <span class="hljs-keyword">this</span>.section = <span class="hljs-string">'default'</span> :</span><span class="actionscript">              <span class="hljs-keyword">this</span>.section = <span class="hljs-string">'header'</span></span>          &#125;        &#125;      &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>filters和watch</title>
    <link href="/2020/07/14/filters%E5%92%8Cwatch/"/>
    <url>/2020/07/14/filters%E5%92%8Cwatch/</url>
    
    <content type="html"><![CDATA[<h2 id="provide和inject跨组件信息传递"><a href="#provide和inject跨组件信息传递" class="headerlink" title="provide和inject跨组件信息传递"></a>provide和inject跨组件信息传递</h2><p>不用 组件一传给组件二，组件二再传给组件三 ，可以直接组件一传给组件二</p><h2 id="filter-amp-watch"><a href="#filter-amp-watch" class="headerlink" title="filter&amp;watch"></a>filter&amp;watch</h2><h3 id="filters用法"><a href="#filters用法" class="headerlink" title="filters用法"></a>filters用法</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>过滤器 filter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>      &#123;&#123;message | lower&#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root'</span>,</span>        filters: &#123;          lower(value) &#123;<span class="actionscript">            <span class="hljs-keyword">return</span> value.toLowerCase()</span>          &#125;        &#125;,        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            message: <span class="hljs-string">'Hello Vue'</span></span>          &#125;        &#125;      &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="watch用法"><a href="#watch用法" class="headerlink" title="watch用法"></a>watch用法</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>监听器 watch<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Watch 用法1：常见用法<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;copyMessage&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root2"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Watch 用法2：绑定方法<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;copyMessage&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root3"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Watch 用法3：deep + handler<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"deepMessage.a.b"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;copyMessage&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root4"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Watch 用法4：immediate<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;copyMessage&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root5"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Watch 用法5：绑定多个 handler<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;copyMessage&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root6"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Watch 用法6：监听对象属性<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"deepMessage.a.b"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;copyMessage&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root'</span>,</span>        watch: &#123;          message(value) &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.copyMessage = value</span>          &#125;        &#125;,        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            message: <span class="hljs-string">'Hello Vue'</span>,</span><span class="actionscript">            copyMessage: <span class="hljs-string">''</span></span>          &#125;        &#125;      &#125;)<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root2'</span>,</span>        watch: &#123;<span class="actionscript">          message: <span class="hljs-string">'handleMessage'</span></span>        &#125;,        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            message: <span class="hljs-string">'Hello Vue'</span>,</span><span class="actionscript">            copyMessage: <span class="hljs-string">''</span></span>          &#125;        &#125;,        methods: &#123;          handleMessage(value) &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.copyMessage = value</span>          &#125;        &#125;      &#125;)<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root3'</span>,</span>        watch: &#123;          deepMessage: &#123;<span class="actionscript">            handler: <span class="hljs-string">'handleDeepMessage'</span>,</span><span class="actionscript">            deep: <span class="hljs-literal">true</span></span>          &#125;        &#125;,        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span>            deepMessage: &#123;              a: &#123;<span class="actionscript">                b: <span class="hljs-string">'Deep Message'</span></span>              &#125;            &#125;,<span class="actionscript">            copyMessage: <span class="hljs-string">''</span></span>          &#125;        &#125;,        methods: &#123;          handleDeepMessage(value) &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.copyMessage = value.a.b</span>          &#125;        &#125;      &#125;)<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root4'</span>,</span>        watch: &#123;          message: &#123;<span class="actionscript">            handler: <span class="hljs-string">'handleMessage'</span>,</span><span class="actionscript">            immediate: <span class="hljs-literal">true</span>,</span>          &#125;        &#125;,        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            message: <span class="hljs-string">'Hello Vue'</span>,</span><span class="actionscript">            copyMessage: <span class="hljs-string">''</span></span>          &#125;        &#125;,        methods: &#123;          handleMessage(value) &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.copyMessage = value</span>          &#125;        &#125;      &#125;),<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root5'</span>,</span>        watch: &#123;          message: [&#123;<span class="actionscript">            handler: <span class="hljs-string">'handleMessage'</span>,</span>          &#125;,<span class="actionscript">          <span class="hljs-string">'handleMessage2'</span>,</span><span class="actionscript">          <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> </span>&#123;</span><span class="actionscript">            <span class="hljs-keyword">this</span>.copyMessage = <span class="hljs-keyword">this</span>.copyMessage + <span class="hljs-string">'...'</span></span>          &#125;]        &#125;,        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            message: <span class="hljs-string">'Hello Vue'</span>,</span><span class="actionscript">            copyMessage: <span class="hljs-string">''</span></span>          &#125;        &#125;,        methods: &#123;          handleMessage(value) &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.copyMessage = value</span>          &#125;,          handleMessage2(value) &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.copyMessage = <span class="hljs-keyword">this</span>.copyMessage + <span class="hljs-string">'*'</span></span>          &#125;        &#125;      &#125;)<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root6'</span>,</span>        watch: &#123;<span class="actionscript">          <span class="hljs-string">'deepMessage.a.b'</span>: <span class="hljs-string">'handleMessage'</span></span>        &#125;,        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            deepMessage: &#123; a: &#123; b: <span class="hljs-string">'Hello Vue'</span> &#125; &#125;,</span><span class="actionscript">            copyMessage: <span class="hljs-string">''</span></span>          &#125;        &#125;,        methods: &#123;          handleMessage(value) &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.copyMessage = value</span>          &#125;        &#125;      &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS高度塌陷和BFC</title>
    <link href="/2020/06/15/CSS%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E5%92%8CBFC/"/>
    <url>/2020/06/15/CSS%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E5%92%8CBFC/</url>
    
    <content type="html"><![CDATA[<h2 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h2><p>当子元素浮动时，脱离了文档流，导致父元素高度撑不起来。<br>这时可以通过在在子元素后面添加内容，并且清楚它的浮动来使其跟在浮动元素的后面，这样就可以撑起父元素的高度了。<br><code>子元素</code>加上下面这个 <code>clearfix</code> 类就可以了。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">''</span>;  <span class="hljs-attribute">display</span>: block;  <span class="hljs-attribute">clear</span>: both;&#125;</code></pre></div><h2 id="相邻元素的外边距重叠"><a href="#相邻元素的外边距重叠" class="headerlink" title="相邻元素的外边距重叠"></a>相邻元素的外边距重叠</h2><p>子元素与父元素，当给子元素设置   <code>margin-top</code> 时，子元素会与父元素一起向下移动，解决方法时使两个元素外边距不重叠。这时可以给<code>父元素</code>加上下面的 <code>clearfix</code> 类来解决。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">clearfix</span><span class="hljs-selector-pseudo">::before</span> &#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">''</span>;  <span class="hljs-attribute">display</span>: table;&#125;</code></pre></div><p>上面两个可以合成一个：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">clearfix</span><span class="hljs-selector-pseudo">::before</span>,<span class="hljs-selector-tag">clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">''</span>;  <span class="hljs-attribute">display</span>: table;  <span class="hljs-attribute">clear</span>: both;&#125;</code></pre></div><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC<code>(Block Formatting Context)</code>块级格式化上下文。具体解释见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">MDN</a><br>这是解决高度塌陷的背后原理，是CSS里面隐藏的属性。<br>高度塌陷还可以通过使父元素生成BFC来解决，通过给父元素添加</p><div class="hljs"><pre><code class="hljs css">&#123;  <span class="hljs-attribute">overflow</span>: hidden;&#125;</code></pre></div><h2 id="图片自适应问题"><a href="#图片自适应问题" class="headerlink" title="图片自适应问题"></a>图片自适应问题</h2><p>通过这样写css，可以直接获取图片高度，而不用等到图片加载出再获得。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">relative</span>;<span class="hljs-selector-tag">width</span>: 100%;<span class="hljs-selector-tag">height</span>: 0;<span class="hljs-selector-tag">padding-top</span>: 70%;<span class="hljs-selector-tag">transfrom-origin</span>: <span class="hljs-selector-tag">top</span>;<span class="hljs-selector-tag">background-size</span>: <span class="hljs-selector-tag">cover</span>;</code></pre></div><p>通过 width:100%和 padding-top:70%控制图片的宽高比为10:7，当页面加载时，宽度确定了，高度也就确定了。</p><p>图片宽度设置100%，页面加载时会存在高度塌陷的问题，可以使用padding－top来设置百分比值来实现自适应 padding-top = (图片的高度/图片的宽度)*100。</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS伪类实现三角形</title>
    <link href="/2020/06/02/CSS%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <url>/2020/06/02/CSS%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS实现三角形"><a href="#CSS实现三角形" class="headerlink" title="CSS实现三角形"></a>CSS实现三角形</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Insert title here<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"colorFlipFlop"</span>&gt;</span><span class="css">  * &#123;<span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;</span><span class="css">  <span class="hljs-selector-class">.demo</span> &#123;</span>    width: 100px;    height: 100px;    position: relative;<span class="css">    <span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#09f</span>;</span>    margin: 100px;  &#125;<span class="css">  <span class="hljs-selector-class">.demo</span><span class="hljs-selector-pseudo">:after</span> &#123;</span>    width: 0px;    height: 0px;    border-width: 12px;    border-style: solid;<span class="css">    <span class="hljs-comment">/* 上 右 下 左 */</span></span><span class="css">    <span class="hljs-selector-tag">border-color</span>: <span class="hljs-selector-tag">transparent</span> <span class="hljs-selector-tag">transparent</span> <span class="hljs-selector-id">#933</span> <span class="hljs-selector-tag">transparent</span>;</span>    position: absolute;    content: ' ';    left: 39px;    top: -24px;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"demo"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="实心三角形"><a href="#实心三角形" class="headerlink" title="实心三角形"></a>实心三角形</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">           <span class="hljs-selector-class">.tri_top</span>, <span class="hljs-selector-class">.tri_right</span>, <span class="hljs-selector-class">.tri_bottom</span>, <span class="hljs-selector-class">.tri_left</span>&#123;</span>               width: 150px;               height: 100px;<span class="css">               <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#CCCCCC</span>;</span>               border-radius: 8px;               margin: 50px 50px;               position: relative;               float: left;           &#125;<span class="css">           <span class="hljs-selector-class">.tri_top</span><span class="hljs-selector-pseudo">:before</span>&#123;</span>               content: "";               width: 0px;               height: 0px;               border-left: 10px solid transparent;               border-right: 10px solid transparent;<span class="css">               <span class="hljs-selector-tag">border-bottom</span>: 10<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#CCCCCC</span>;</span>               position: absolute;               top: -10px;               left: 65px;           &#125;<span class="css">           <span class="hljs-selector-class">.tri_right</span><span class="hljs-selector-pseudo">:before</span>&#123;</span>               content: "";               width: 0px;               height: 0px;               border-top: 10px solid transparent;               border-bottom: 10px solid transparent;<span class="css">               <span class="hljs-selector-tag">border-left</span>: 10<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#CCCCCC</span>;</span>               position: absolute;               top: 40px;               left: 150px;           &#125;<span class="css">           <span class="hljs-selector-class">.tri_bottom</span><span class="hljs-selector-pseudo">:before</span>&#123;</span>               content: "";               width: 0px;               height: 0px;<span class="css">               <span class="hljs-selector-tag">border-top</span>: 10<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#CCCCCC</span>;</span>               border-left: 10px solid transparent;               border-right: 10px solid transparent;               position: absolute;               top: 100px;               left: 70px;           &#125;<span class="css">           <span class="hljs-selector-class">.tri_left</span><span class="hljs-selector-pseudo">:before</span>&#123;</span>               content: "";               width: 0px;               height: 0px;               border-top: 10px solid transparent;               border-bottom: 10px solid transparent;<span class="css">               <span class="hljs-selector-tag">border-right</span>: 10<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#CCCCCC</span>;</span>               position: absolute;               top: 40px;               left: -10px;           &#125;       <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tri_top"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>         <span class="hljs-comment">&lt;!--三角形在上边--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tri_right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-comment">&lt;!--三角形在右边--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tri_bottom"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-comment">&lt;!--三角形在底边--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tri_left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-comment">&lt;!--三角形在左边--&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p><img src="/img/CSS%E4%BC%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2/tri.png" srcset="/img/loading.gif" alt="实心三角形"></p><h3 id="空心三角形"><a href="#空心三角形" class="headerlink" title="空心三角形"></a>空心三角形</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">            <span class="hljs-selector-class">.tri_top</span>, <span class="hljs-selector-class">.tri_right</span>, <span class="hljs-selector-class">.tri_bottom</span>, <span class="hljs-selector-class">.tri_left</span>&#123;</span>                width: 150px;                height: 100px;<span class="css">                <span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#000000</span>;</span>                border-radius: 8px;                margin: 50px 50px;                position: relative;                float: left;            &#125;<span class="css">            <span class="hljs-selector-class">.tri_top</span><span class="hljs-selector-pseudo">:before</span>&#123;</span>                content: "";                width: 0px;                height: 0px;                border-left: 15px solid transparent;                border-right: 15px solid transparent;<span class="css">                <span class="hljs-selector-tag">border-bottom</span>: 15<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#000000</span>;</span>                position: absolute;                top: -15px;                left: 65px;            &#125;<span class="css">            <span class="hljs-selector-class">.tri_top</span><span class="hljs-selector-pseudo">:after</span>&#123;</span>                content: "";                width: 0px;                height: 0px;                border-left: 14px solid transparent;                border-right: 14px solid transparent;<span class="css">                <span class="hljs-selector-tag">border-bottom</span>: 14<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#FFFFFF</span>;</span>                position: absolute;                top: -14px;                left: 66px;            &#125;<span class="css">            <span class="hljs-selector-class">.tri_right</span><span class="hljs-selector-pseudo">:before</span>&#123;</span>                content: "";                width: 0px;                height: 0px;                border-top: 15px solid transparent;                border-bottom: 15px solid transparent;<span class="css">                <span class="hljs-selector-tag">border-left</span>: 15<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#000000</span>;</span>                position: absolute;                top: 39px;                left: 150px;            &#125;<span class="css">            <span class="hljs-selector-class">.tri_right</span><span class="hljs-selector-pseudo">:after</span>&#123;</span>                content: "";                width: 0px;                height: 0px;                border-top: 14px solid transparent;                border-bottom: 14px solid transparent;<span class="css">                <span class="hljs-selector-tag">border-left</span>: 14<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#FFFFFF</span>;</span>                position: absolute;                top: 40px;                left: 149px;            &#125;<span class="css">            <span class="hljs-selector-class">.tri_bottom</span><span class="hljs-selector-pseudo">:before</span>&#123;</span>                content: "";                width: 0px;                height: 0px;<span class="css">                <span class="hljs-selector-tag">border-top</span>: 15<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#000000</span>;</span>                border-left: 15px solid transparent;                border-right: 15px solid transparent;                position: absolute;                top: 101px;                left: 69px;            &#125;<span class="css">            <span class="hljs-selector-class">.tri_bottom</span><span class="hljs-selector-pseudo">:after</span>&#123;</span>                content: "";                width: 0px;                height: 0px;<span class="css">                <span class="hljs-selector-tag">border-top</span>: 14<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#FFFFFF</span>;</span>                border-left: 14px solid transparent;                border-right: 14px solid transparent;                position: absolute;                top: 100px;                left: 70px;            &#125;<span class="css">            <span class="hljs-selector-class">.tri_left</span><span class="hljs-selector-pseudo">:before</span>&#123;</span>                content: "";                width: 0px;                height: 0px;                border-top: 15px solid transparent;                border-bottom: 15px solid transparent;<span class="css">                <span class="hljs-selector-tag">border-right</span>: 15<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#000000</span>;</span>                position: absolute;                top: 40px;                left: -15px;            &#125;<span class="css">            <span class="hljs-selector-class">.tri_left</span><span class="hljs-selector-pseudo">:after</span>&#123;</span>                content: "";                width: 0px;                height: 0px;                border-top: 14px solid transparent;                border-bottom: 14px solid transparent;<span class="css">                <span class="hljs-selector-tag">border-right</span>: 14<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#FFFFFF</span>;</span>                position: absolute;                top: 41px;                left: -14px;            &#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tri_top"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>         <span class="hljs-comment">&lt;!--三角形在上边--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tri_right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-comment">&lt;!--三角形在右边--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tri_bottom"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-comment">&lt;!--三角形在底边--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tri_left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-comment">&lt;!--三角形在左边--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p><img src="/img/CSS%E4%BC%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2/tri2.png" srcset="/img/loading.gif" alt="空心三角形"></p><p>总结：<br> 三角形往哪个方向，那个方向无需设置border，而相反方向设置border颜色，相邻两边的border设为透明。这样就可实现各个方向的三角形。实心三角形利用CSS中的伪元素（：before）实现，再利用border的transparent属性即可达到效果。而空心三角形是在空心三角形的基础上再加上伪元素（：after）实现。伪元素（：before）实现的是一个实心的三角形，伪元素（：after）实现的是空心的三角形，进而把实心的三角形覆盖，利用绝对定位的top与left的差值绝对了三角形线的粗细而达到如图的效果。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10更新后闪屏处理方法</title>
    <link href="/2020/05/30/win10%E6%9B%B4%E6%96%B0%E5%90%8E%E9%97%AA%E5%B1%8F%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <url>/2020/05/30/win10%E6%9B%B4%E6%96%B0%E5%90%8E%E9%97%AA%E5%B1%8F%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="win10更新后闪屏处理方法"><a href="#win10更新后闪屏处理方法" class="headerlink" title="win10更新后闪屏处理方法"></a>win10更新后闪屏处理方法</h2><p>在我的电脑上处理成功了，但是中途没有拍照，我把详细过程说一下。</p><ol><li>按下 <code>Ctrl+Alt+Delete</code> ，出现任务管理器选择的界面</li><li>一直按着 <code>Shift</code>，同时点击右下角 <code>关机</code> 按钮，选择 <code>重启</code> ，<code>Shift</code> 不要松。</li><li>出现选项后选择 <code>疑难解答</code>。</li><li>点击 <code>高级选项</code>。</li><li>点击 <code>卸载更新</code>。</li><li>点击 <code>卸载最新的质量更新</code>。</li><li>然后就 <code>选择用户</code>，<code>输入密码</code>，<code>确定</code> 就行了。后面系统自动卸载和重启。</li><li>重启后最好不要让 win10 再更新了，可以下载一个 windows 优化的软件，<code>Dism++</code> 很好用。这里是<a href="https://www.chuyu.me/zh-Hans/index.html" target="_blank" rel="noopener">Dism++官网</a><br><img src="/img/win10%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5/dism.png" srcset="/img/loading.gif" alt="dism"></li></ol>]]></content>
    
    
    <categories>
      
      <category>错误</category>
      
    </categories>
    
    
    <tags>
      
      <tag>win</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css伪元素导航栏分割线</title>
    <link href="/2020/05/27/css%E4%BC%AA%E5%85%83%E7%B4%A0%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%88%86%E5%89%B2%E7%BA%BF/"/>
    <url>/2020/05/27/css%E4%BC%AA%E5%85%83%E7%B4%A0%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%88%86%E5%89%B2%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="分割线伪类"><a href="#分割线伪类" class="headerlink" title="分割线伪类"></a>分割线伪类</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/*使用伪元素制作导航列表项分隔线*/</span><span class="hljs-selector-class">.nav</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:after</span>&#123;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-attribute">content</span>:<span class="hljs-string">"|"</span>;  <span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">color</span>:<span class="hljs-number">#fff</span>;  <span class="hljs-attribute">text-shadow</span>:<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,.<span class="hljs-number">5</span>);&#125;<span class="hljs-comment">/*删除最后一项导航分隔线*/</span><span class="hljs-selector-class">.nav</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span><span class="hljs-selector-pseudo">::after</span>&#123;  <span class="hljs-attribute">content</span>:<span class="hljs-string">""</span>; &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue进阶语法</title>
    <link href="/2020/05/27/vue%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/05/27/vue%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="vue的部分进阶语法"><a href="#vue的部分进阶语法" class="headerlink" title="vue的部分进阶语法"></a>vue的部分进阶语法</h2><p>学习一下，做下总结</p><h3 id="emit和-on"><a href="#emit和-on" class="headerlink" title="$emit和$on"></a>$emit和$on</h3><blockquote><p>本文内容引自<a href="http://www.youbaobao.xyz/admin-docs/guide/base/vue.html" target="_blank" rel="noopener">这里</a></p></blockquote><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>$emit 和 $on<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"boost"</span>&gt;</span>触发事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root'</span>,</span>        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            message: <span class="hljs-string">'hello vue'</span></span>          &#125;        &#125;,        created() &#123;<span class="actionscript">          <span class="hljs-keyword">this</span>.$on(<span class="hljs-string">'my_events'</span>, <span class="hljs-keyword">this</span>.handleEvents)</span>        &#125;,        methods: &#123;          handleEvents(e) &#123;<span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.message, e)</span>          &#125;,          boost() &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'my_events'</span>, <span class="hljs-string">'my params'</span>)</span>          &#125;        &#125;      &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>使用this.$on时既可以一个事件绑定多个处理函数，也可以多个事件绑定一个处理函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">this</span>.$on(<span class="hljs-string">'event1'</span>,<span class="hljs-keyword">this</span>.handleEvents1)<span class="hljs-keyword">this</span>.$on(<span class="hljs-string">'event1'</span>,<span class="hljs-keyword">this</span>.handleEvents2)</code></pre></div><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">this</span>.$on([<span class="hljs-string">'event1'</span>,<span class="hljs-string">'event2'</span>],<span class="hljs-keyword">this</span>.handleEvents)</code></pre></div><h3 id="directive-用法"><a href="#directive-用法" class="headerlink" title="directive 用法"></a>directive 用法</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>directive 用法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-loading</span>=<span class="hljs-string">"isLoading"</span>&gt;</span>&#123;&#123;data&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"update"</span>&gt;</span>更新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">      Vue.directive(<span class="hljs-string">'loading'</span>, &#123;</span>        update(el, binding, vnode) &#123;          if (binding.value) &#123;<span class="javascript">            <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>)</span><span class="actionscript">            div.innerText = <span class="hljs-string">'加载中...'</span></span><span class="actionscript">            div.setAttribute(<span class="hljs-string">'id'</span>, <span class="hljs-string">'loading'</span>)</span><span class="actionscript">            div.style.position = <span class="hljs-string">'absolute'</span></span>            div.style.left = 0            div.style.top = 0<span class="actionscript">            div.style.width = <span class="hljs-string">'100%'</span></span><span class="actionscript">            div.style.height = <span class="hljs-string">'100%'</span></span><span class="actionscript">            div.style.display = <span class="hljs-string">'flex'</span></span><span class="actionscript">            div.style.justifyContent = <span class="hljs-string">'center'</span></span><span class="actionscript">            div.style.alignItems = <span class="hljs-string">'center'</span></span><span class="actionscript">            div.style.color = <span class="hljs-string">'white'</span></span><span class="actionscript">            div.style.background = <span class="hljs-string">'rgba(0, 0, 0, .7)'</span></span><span class="javascript">            <span class="hljs-built_in">document</span>.body.append(div)</span><span class="actionscript">          &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="javascript">            <span class="hljs-built_in">document</span>.body.removeChild(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'loading'</span>))</span>          &#125;        &#125;      &#125;)<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root'</span>,</span>        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            isLoading: <span class="hljs-literal">false</span>,</span><span class="actionscript">            data: <span class="hljs-string">''</span></span>          &#125;        &#125;,        methods: &#123;          update() &#123;<span class="actionscript">            <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">true</span></span><span class="javascript">            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><span class="actionscript">              <span class="hljs-keyword">this</span>.data = <span class="hljs-string">'用户数据'</span></span><span class="actionscript">              <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">false</span></span>            &#125;, 3000)          &#125;        &#125;      &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>通过directive命令可以创造自定义的指令，通过 v-指令名 进行使用，方便解耦复用。</p><p class="note note-primary">TIP</br>官方文档：<a href="https://cn.vuejs.org/v2/api/#Vue-directive" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#Vue-directive</a></p><h3 id="Vue-component-用法"><a href="#Vue-component-用法" class="headerlink" title="Vue.component 用法"></a>Vue.component 用法</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue.component 用法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">Test</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Test</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">      Vue.component(<span class="hljs-string">'Test'</span>, &#123;</span><span class="handlebars"><span class="xml">        template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;msg&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>',</span></span>        props: &#123;          msg: &#123;<span class="javascript">            type: <span class="hljs-built_in">String</span>,</span><span class="actionscript">            <span class="hljs-keyword">default</span>: <span class="hljs-string">'default message'</span></span>          &#125;        &#125;      &#125;)<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root'</span>,</span>        data() &#123;<span class="actionscript">          <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">            message: <span class="hljs-string">"Test Component"</span></span>          &#125;        &#125;      &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="Vue-extend-进阶用法"><a href="#Vue-extend-进阶用法" class="headerlink" title="Vue.extend 进阶用法"></a>Vue.extend 进阶用法</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue.extend 用法2<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">      <span class="hljs-selector-id">#loading-wrapper</span> &#123;</span>        position: fixed;        top: 0;        left: 0;        display: flex;        justify-content: center;        align-items: center;        width: 100%;        height: 100%;<span class="css">        <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-tag">rgba</span>(0,0,0,<span class="hljs-selector-class">.7</span>);</span><span class="css">        <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#fff</span>;</span>      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"showLoading"</span>&gt;</span>显示Loading<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Loading</span><span class="hljs-params">(msg)</span> </span>&#123;</span><span class="actionscript">        <span class="hljs-keyword">const</span> LoadingComponent = Vue.extend(&#123;</span><span class="handlebars"><span class="xml">          template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loading-wrapper"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;msg&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>',</span></span>          props: &#123;            msg: &#123;<span class="javascript">              type: <span class="hljs-built_in">String</span>,</span><span class="actionscript">              <span class="hljs-keyword">default</span>: msg</span>            &#125;          &#125;,<span class="actionscript">          name: <span class="hljs-string">'LoadingComponent'</span></span>        &#125;)<span class="javascript">        <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>)</span><span class="actionscript">        div.setAttribute(<span class="hljs-string">'id'</span>, <span class="hljs-string">'loading-wrapper'</span>)</span><span class="javascript">        <span class="hljs-built_in">document</span>.body.append(div)</span><span class="actionscript">        <span class="hljs-keyword">new</span> LoadingComponent().$mount(<span class="hljs-string">'#loading-wrapper'</span>)</span><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><span class="javascript">          <span class="hljs-built_in">document</span>.body.removeChild(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'loading-wrapper'</span>))</span>        &#125;      &#125;      Vue.prototype.$loading = Loading<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root'</span>,</span>        methods: &#123;          showLoading() &#123;<span class="actionscript">            <span class="hljs-keyword">const</span> hide = <span class="hljs-keyword">this</span>.$loading(<span class="hljs-string">'正在加载，请稍等...'</span>)</span><span class="javascript">            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span>              hide()            &#125;, 2000)          &#125;        &#125;      &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>将 loading 挂载到 Vue 原型上，通过 this.$loading 使用，比通过 directive 方法更加方便。</p><h3 id="Vue-use-用法"><a href="#Vue-use-用法" class="headerlink" title="Vue.use 用法"></a>Vue.use 用法</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue.use 用法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">      <span class="hljs-selector-id">#loading-wrapper</span> &#123;</span>        position: fixed;        top: 0;        left: 0;        display: flex;        justify-content: center;        align-items: center;        width: 100%;        height: 100%;<span class="css">        <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-tag">rgba</span>(0,0,0,<span class="hljs-selector-class">.7</span>);</span><span class="css">        <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#fff</span>;</span>      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"showLoading"</span>&gt;</span>显示Loading<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">      <span class="hljs-keyword">const</span> loadingPlugin = &#123;</span><span class="actionscript">        install: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(vm)</span> </span>&#123;</span><span class="actionscript">          <span class="hljs-keyword">const</span> LoadingComponent = vm.extend(&#123;</span><span class="handlebars"><span class="xml">            template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loading-wrapper"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;msg&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>',</span></span>            props: &#123;              msg: &#123;<span class="javascript">                type: <span class="hljs-built_in">String</span>,</span><span class="actionscript">                <span class="hljs-keyword">default</span>: <span class="hljs-string">'loading...'</span></span>              &#125;            &#125;<span class="actionscript">          &#125;, <span class="hljs-string">'LoadingComponent'</span>)</span><span class="actionscript">          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Loading</span><span class="hljs-params">(msg)</span> </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>)</span><span class="actionscript">            div.setAttribute(<span class="hljs-string">'id'</span>, <span class="hljs-string">'loading-wrapper'</span>)</span><span class="javascript">            <span class="hljs-built_in">document</span>.body.append(div)</span><span class="actionscript">            <span class="hljs-keyword">new</span> LoadingComponent(&#123;</span>              props: &#123;                msg: &#123;<span class="javascript">                  type: <span class="hljs-built_in">String</span>,</span><span class="actionscript">                  <span class="hljs-keyword">default</span>: msg</span>                &#125;              &#125;<span class="actionscript">            &#125;).$mount(<span class="hljs-string">'#loading-wrapper'</span>)</span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><span class="javascript">              <span class="hljs-built_in">document</span>.body.removeChild(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'loading-wrapper'</span>))</span>            &#125;          &#125;          vm.prototype.$loading = Loading        &#125;      &#125;      Vue.use(loadingPlugin)<span class="actionscript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#root'</span>,</span>        methods: &#123;          showLoading() &#123;<span class="actionscript">            <span class="hljs-keyword">const</span> hide = <span class="hljs-keyword">this</span>.$loading(<span class="hljs-string">'正在加载，请稍等...'</span>)</span><span class="javascript">            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span>              hide()            &#125;, 2000)          &#125;        &#125;      &#125;)    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>这种方法彻底把 loading 做成了一个插件，可以把主要插件内容放到别的文件中，然后通过 import 后用 Vue.use 来使用，更加解耦和方便。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
